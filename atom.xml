<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Time渐行渐远</title>
  
  <subtitle>Coding Changing The World</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dmlcoding.com/"/>
  <updated>2017-08-24T13:00:16.000Z</updated>
  <id>http://dmlcoding.com/</id>
  
  <author>
    <name>Hushiwei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>诗经 &lt;&lt;伐檀&gt;&gt;</title>
    <link href="http://dmlcoding.com/2017/fatan/"/>
    <id>http://dmlcoding.com/2017/fatan/</id>
    <published>2017-08-23T12:30:00.000Z</published>
    <updated>2017-08-24T13:00:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/beautifulPic/fatan.png" alt="fatan"></p><a id="more"></a><blockquote><p>抄一首诗,换个心情…</p></blockquote><h1 id="伐檀"><a href="#伐檀" class="headerlink" title="伐檀"></a>伐檀</h1><p>坎坎伐檀兮，置之河之干兮，河水清且涟猗。<br>不稼不穑，胡取禾三百廛[1]兮？<br>不狩不猎，胡瞻尔庭有县[2]貆兮？<br>彼君子兮，不素餐兮！</p><p>坎坎伐辐兮，置之河之侧兮，河水清且直猗。<br>不稼不穑，胡取禾三百亿兮？<br>不狩不猎，胡瞻尔庭有县特[3]兮？<br>彼君子兮，不素食兮！</p><p>坎坎伐轮兮，置之河之漘[4]兮，河水清且沦猗。<br>不稼不穑，胡取禾三百囷[5]兮？<br>不狩不猎，胡瞻尔庭有县鹑兮？<br>彼君子兮，不素飧兮！</p><h1 id="伐檀白话"><a href="#伐檀白话" class="headerlink" title="伐檀白话"></a>伐檀白话</h1><p>砍伐檀树声坎坎啊，<br>棵棵放倒堆河边啊，<br>河水清清微波转哟。<br>不播种来不收割，<br>为何三百捆禾往家搬啊？<br>不冬狩来不夜猎，<br>为何见你庭院猪獾悬啊？<br>那些老爷君子啊，<br>不会白吃闲饭啊！</p><p>砍下檀树做车辐啊，<br>放在河边堆一处啊。<br>河水清清直流注哟。<br>不播种来不收割，<br>为何三百捆禾要独取啊？<br>不冬狩来不夜猎，<br>为何见你庭院兽悬柱啊？<br>那些老爷君子啊，<br>不会白吃饱腹啊！</p><p>砍下檀树做车轮啊，<br>棵棵放倒河边屯啊。<br>河水清清起波纹啊。<br>不播种来不收割，<br>为何三百捆禾要独吞啊？<br>不冬狩来不夜猎，<br>为何见你庭院挂鹌鹑啊？<br>那些老爷君子啊，<br>可不白吃腥荤啊！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/beautifulPic/fatan.png&quot; alt=&quot;fatan&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="book" scheme="http://dmlcoding.com/categories/book/"/>
    
    
      <category term="book" scheme="http://dmlcoding.com/tags/book/"/>
    
      <category term="think" scheme="http://dmlcoding.com/tags/think/"/>
    
  </entry>
  
  <entry>
    <title>ITerm2下使用ssh访问Linux(包括堡垒机)</title>
    <link href="http://dmlcoding.com/2017/MacSsh/"/>
    <id>http://dmlcoding.com/2017/MacSsh/</id>
    <published>2017-08-17T02:00:00.000Z</published>
    <updated>2017-08-18T04:01:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>mac下没有xshell,虽然有SecurtCRT,但是真的太丑了.我还是比较喜欢用Iterm2来进行远程连接.<br>这样不可避免的会碰到要记录远程密码,如果每次都输入,那就太麻烦了.<br><a id="more"></a></p><h1 id="Iterm2下使用ssh访问Linux"><a href="#Iterm2下使用ssh访问Linux" class="headerlink" title="Iterm2下使用ssh访问Linux"></a>Iterm2下使用ssh访问Linux</h1><p>通过情况下,Iterm2访问远程Linux使用ssh命令,如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh &lt;用户名&gt;@&lt;ip&gt;</div></pre></td></tr></table></figure></p><p>然后输入访问密码即可登录进去.有时候远程访问的默认端口如果不是22,那就需要额外加上<code>-p</code>参数跟上远程访问端口进行登录了.<br>很明显如果每次都要输入访问密码,那在开发过程中是相当的不方便的.</p><p>这里有两个方式实现免密登录.都是用Iterm2的Profiles功能加上脚本来实现.</p><h2 id="方式1-使用spawn脚本文件"><a href="#方式1-使用spawn脚本文件" class="headerlink" title="方式1:使用spawn脚本文件"></a>方式1:使用spawn脚本文件</h2><p>将远程访问的相关内容写成一个脚本,然后在Profile里面调用即可.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd /Users/hushiwei/.ssh/</div><div class="line">$ touch filename</div></pre></td></tr></table></figure></p><p>脚本内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/expect -f</div><div class="line">  set user &lt;用户名&gt;</div><div class="line">  set host &lt;ip地址&gt;</div><div class="line">  set password &lt;密码&gt;</div><div class="line">  set timeout -1</div><div class="line"></div><div class="line">  spawn ssh $user@$host</div><div class="line">  expect &quot;*assword:*&quot;</div><div class="line">  send &quot;$password\r&quot;</div><div class="line">  interact</div><div class="line">  expect eof</div></pre></td></tr></table></figure></p><p>如何调用呢?<br>在command中使用命令.command在哪看下面的图你就知道了.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">expect &lt;保存的脚本完整路径&gt;</div></pre></td></tr></table></figure></p><h2 id="方式2-使用sshpass-推荐方式"><a href="#方式2-使用sshpass-推荐方式" class="headerlink" title="方式2:使用sshpass(推荐方式)"></a>方式2:使用sshpass(推荐方式)</h2><p>brew安装sshpass<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install https://raw.githubusercontent.com/kadwanev/bigboybrew/master/Library/Formula/sshpass.rb</div></pre></td></tr></table></figure></p><p>然后把密码写入到一个文件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">hushiwei@localhost  ~/sshpass  pwd</div><div class="line">/Users/hushiwei/sshpass</div><div class="line">hushiwei@localhost  ~/sshpass  more pass</div><div class="line">passwd123</div></pre></td></tr></table></figure></p><p>参考图中进行配置<br><img src="/images/pics/sshpass.png" alt="sshpass"></p><p>command写上命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/bin/sshpass -f /Users/hushiwei/sshpass/pass ssh -p22 用户名@密码</div></pre></td></tr></table></figure></p><p>然后在iterm2的菜单栏选择Profiles,然后点击刚刚的配置,即可免密自动登录到服务器上</p><ul><li>注意:首先用命令行登录一次</li></ul><h1 id="iterm2登录堡垒机"><a href="#iterm2登录堡垒机" class="headerlink" title="iterm2登录堡垒机"></a>iterm2登录堡垒机</h1><p>通过SSH和密钥文件(.pem格式)登录服务器［可能是堡垒机］</p><h2 id="首先修改下密钥文件权限"><a href="#首先修改下密钥文件权限" class="headerlink" title="首先修改下密钥文件权限"></a>首先修改下密钥文件权限</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chmod 600 /Users/hushiwei/sshpass/Jumpserver/hushiwei.pem</div></pre></td></tr></table></figure><h2 id="其次，终端可直接命令连接"><a href="#其次，终端可直接命令连接" class="headerlink" title="其次，终端可直接命令连接"></a>其次，终端可直接命令连接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -i /Users/hushiwei/sshpass/Jumpserver/hushiwei.pem hushiwei@xxx.xxx.xxx.xxx</div></pre></td></tr></table></figure><p>注：首次连接时，会弹出密钥文件密码输入框，可以输入并保存！</p><p>除了直接命令连接外，也可参考上面Profiles功能，配置好，直接在Profile里调用！简单脚本如下：</p><h2 id="配置Profile脚本自动登录堡垒机"><a href="#配置Profile脚本自动登录堡垒机" class="headerlink" title="配置Profile脚本自动登录堡垒机"></a>配置Profile脚本自动登录堡垒机</h2><p>脚本文件 vim jumpserver<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">hushiwei@localhost  ~/sshpass/Jumpserver  more jumpserver</div><div class="line">#!/usr/bin/expect -f</div><div class="line"> set user hushiwei</div><div class="line"> set host xxx.xxx.xxx.xxx</div><div class="line"> set empath /Users/hushiwei/sshpass/Jumpserver/hushiwei.pem</div><div class="line"> set timeout -1</div><div class="line"></div><div class="line"> spawn ssh -i $empath $user@$host</div><div class="line"> interact</div><div class="line"> expect eof</div></pre></td></tr></table></figure></p><p>命令行执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">hushiwei@localhost  ~/sshpass/Jumpserver  expect /Users/hushiwei/sshpass/Jumpserver/jumpserver</div><div class="line">spawn ssh -i /Users/hushiwei/sshpass/Jumpserver/hushiwei.pem hushiwei@xxx.xxx.xxx.xxx</div><div class="line">Last login: Fri Aug 18 11:06:16 2017 from xxx.xxx.xxx.xxx</div><div class="line"></div><div class="line">###    欢迎使用Jumpserver开源跳板机系统   ###</div><div class="line"></div><div class="line">       1) 输入 ID 直接登录 或 输入部分 IP,主机名,备注 进行搜索登录(如果唯一).</div><div class="line">       2) 输入 / + IP, 主机名 or 备注 搜索. 如: /ip</div><div class="line">       3) 输入 P/p 显示您有权限的主机.</div><div class="line">       4) 输入 G/g 显示您有权限的主机组.</div><div class="line">       5) 输入 G/g + 组ID 显示该组下主机. 如: g1</div><div class="line">       6) 输入 E/e 批量执行命令.</div><div class="line">       7) 输入 U/u 批量上传文件.</div><div class="line">       8) 输入 D/d 批量下载文件.</div><div class="line">       9) 输入 H/h 帮助.</div><div class="line">       0) 输入 Q/q 退出.</div><div class="line"></div><div class="line">Opt or ID&gt;:</div></pre></td></tr></table></figure></p><p>参考上面的Profile功能,配置好,直接在Profile里调用即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 在Command里面写入以下即可</div><div class="line">expect /Users/hushiwei/sshpass/Jumpserver/jumpserver</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mac下没有xshell,虽然有SecurtCRT,但是真的太丑了.我还是比较喜欢用Iterm2来进行远程连接.&lt;br&gt;这样不可避免的会碰到要记录远程密码,如果每次都输入,那就太麻烦了.&lt;br&gt;
    
    </summary>
    
      <category term="mac" scheme="http://dmlcoding.com/categories/mac/"/>
    
    
      <category term="mac" scheme="http://dmlcoding.com/tags/mac/"/>
    
      <category term="ssh" scheme="http://dmlcoding.com/tags/ssh/"/>
    
      <category term="iterm2" scheme="http://dmlcoding.com/tags/iterm2/"/>
    
  </entry>
  
  <entry>
    <title>监控SparkStreaming程序脚本</title>
    <link href="http://dmlcoding.com/2017/MonitorSparkStreamingOnYarn/"/>
    <id>http://dmlcoding.com/2017/MonitorSparkStreamingOnYarn/</id>
    <published>2017-08-15T02:00:00.000Z</published>
    <updated>2017-08-15T12:46:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>虽然Spark on yarn非常的稳定,一般情况下是不会出问题的.但是我们的SparkStreaming程序是一直运行着出实时报表的.<br>我们必须得对SparkStreaming程序进行监控,在程序退出后,能够及时的重启.<br>基于此需求,我想到了通过调用yarn的rest接口来获取提交到yarn上的任务</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>调用yarn提供的rest接口来获取所有正在运行的任务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl --compressed -H &quot;Accept: application/json&quot; -X GET &quot;http://master:8088/ws/v1/cluster/apps?states=RUNNING&quot;</div></pre></td></tr></table></figure></p><p>如果对别的接口有兴趣,可以看看官网.</p><ul><li><a href="https://hadoop.apache.org/docs/stable/hadoop-yarn/hadoop-yarn-site/ResourceManagerRest.html" target="_blank" rel="external">https://hadoop.apache.org/docs/stable/hadoop-yarn/hadoop-yarn-site/ResourceManagerRest.html</a></li><li><a href="http://www.winseliu.com/blog/2014/12/07/hadoop-mr-rest-api/" target="_blank" rel="external">http://www.winseliu.com/blog/2014/12/07/hadoop-mr-rest-api/</a></li></ul><h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><p>脚本也很简单,简单看看就明白了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"># -*- coding: utf-8 -*-</div><div class="line">&apos;&apos;&apos;</div><div class="line">    Created by hushiwei on 2017/7/20.</div><div class="line">&apos;&apos;&apos;</div><div class="line">&apos;&apos;&apos;</div><div class="line">通过调用yarn的rest接口,来监控sparkstreaming程序</div><div class="line">&apos;&apos;&apos;</div><div class="line">import json</div><div class="line">import subprocess</div><div class="line"></div><div class="line">apps = &#123;</div><div class="line">    &quot;com.xxx.streaming.ADXStreaming&quot;: &quot;sh ./start_adx_streaming_yarn.sh&quot;,</div><div class="line">    &quot;com.xxx.streaming.DSPStreaming&quot;: &quot;sh ./start_dsp_streaming_yarn.sh&quot;,</div><div class="line">    &quot;com.xxx.streaming.CPDAppStreaming&quot;: &quot;sh ./start_dsp_app_promotion_yarn.sh&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">def run_it(cmd):</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    通过python执行shell命令</div><div class="line">    :param cmd:</div><div class="line">    :return:</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, shell=True,</div><div class="line">                         stderr=subprocess.PIPE)</div><div class="line">    # print (&apos;running:%s&apos; % cmd)</div><div class="line">    out, err = p.communicate()</div><div class="line">    if p.returncode != 0:</div><div class="line">        print (&quot;Non zero exit code:%s executing: %s \nerr course ---&gt; %s&quot; % (p.returncode, cmd, err))</div><div class="line">    return out</div><div class="line"></div><div class="line"></div><div class="line">def runSparkStreaming(packageName):</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    调用执行脚本</div><div class="line">    :return:</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    print &quot;going to exec sparkstreaming program : %s&quot; % packageName</div><div class="line">    run_it(apps[packageName])</div><div class="line"></div><div class="line"></div><div class="line">def collectPackageName(str):</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    获取正则运行的所有包名</div><div class="line">    :param str:</div><div class="line">    :return:</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    packages = &#123;&#125;</div><div class="line">    obj = json.loads(str)</div><div class="line">    apps = obj[&apos;apps&apos;][&apos;app&apos;]</div><div class="line">    for app in apps:</div><div class="line">        packages[app[&apos;name&apos;]] = app[&apos;state&apos;]</div><div class="line"></div><div class="line">    return packages</div><div class="line"></div><div class="line"></div><div class="line">def findPackage(packageNames, packages):</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    根据包名判断该程序是否正在运行中,</div><div class="line">    若失败了,则执行重启任务的脚本</div><div class="line">    :param packageNames: 需要监控的包名们(list,可以监控多个包)</div><div class="line">    :param packages: yarn上正在执行的所有任务</div><div class="line">    :return:</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    for packageName in packageNames:</div><div class="line">        if packageName in packages.keys():</div><div class="line">            print packageName + &quot; is: &quot; + packages[packageName]</div><div class="line">        else:</div><div class="line">            print packageName + &quot; is failed! &quot;</div><div class="line">            runSparkStreaming(packageName)</div><div class="line"></div><div class="line"></div><div class="line">str = run_it(</div><div class="line">    &apos;curl --compressed -H &quot;Accept: application/json&quot; -X GET &quot;http://master:8088/ws/v1/cluster/apps?states=RUNNING&quot;&apos;)</div><div class="line">packages = collectPackageName(str)</div><div class="line"></div><div class="line">packageNames = [&apos;com.xxx.streaming.DSPStreaming&apos;,&apos;com.xxx.streaming.CPDAppStreaming&apos;,&apos;com.xxx.streaming.ADXStreaming&apos;]</div><div class="line">findPackage(packageNames, packages)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然Spark on yarn非常的稳定,一般情况下是不会出问题的.但是我们的SparkStreaming程序是一直运行着出实时报表的.&lt;br&gt;我们必须得对SparkStreaming程序进行监控,在程序退出后,能够及时的重启.&lt;br&gt;基于此需求,我想到了通过调用yarn的rest接口来获取提交到yarn上的任务&lt;/p&gt;
    
    </summary>
    
      <category term="spark" scheme="http://dmlcoding.com/categories/spark/"/>
    
    
      <category term="spark" scheme="http://dmlcoding.com/tags/spark/"/>
    
      <category term="yarn" scheme="http://dmlcoding.com/tags/yarn/"/>
    
  </entry>
  
  <entry>
    <title>YARN 资源分配的配置参数</title>
    <link href="http://dmlcoding.com/2017/SparkOnYarn/"/>
    <id>http://dmlcoding.com/2017/SparkOnYarn/</id>
    <published>2017-08-08T02:00:00.000Z</published>
    <updated>2017-08-16T07:36:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>无论是mapreduce程序或者是Spark程序,提交到Yarn上来进行资源管理与分配的时候.都是运行在Yarn的Container容器中.<br>而Container容器中是Yarn封装的内存和CPU资源.暂时还不支持对网络IO等资源进行封装分配.那么在开发调优过程中,我们肯定无法避免会对内存进行一些分配.那么Yarn的哪些配置参数是对哪个地方进行分配的,就很重要,也就值得记一记.<br><a id="more"></a></p><h1 id="内存资源"><a href="#内存资源" class="headerlink" title="内存资源"></a>内存资源</h1><h2 id="ResourceManager"><a href="#ResourceManager" class="headerlink" title="ResourceManager"></a>ResourceManager</h2><table><thead><tr><th style="text-align:left">配置参数</th><th style="text-align:left">说明</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">yarn.scheduler.minimum-allocation-mb</td><td style="text-align:left">单个任务可申请的最少物理内存量，默认是1024（MB），如果一个任务申请的物理内存量少于该值，则该对应的值改为这个数</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">yarn.scheduler.maximum-allocation-mb</td><td style="text-align:left">单个任务可申请的最多物理内存量，默认是8192（MB)</td></tr></tbody></table><p>说明:<br>也就是ResourceManager启动的Container容器的最大与最小内存.</p><h2 id="nodemanager"><a href="#nodemanager" class="headerlink" title="nodemanager"></a>nodemanager</h2><table><thead><tr><th style="text-align:left">配置参数</th><th style="text-align:left">说明</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">yarn.nodemanager.resource.memory-mb</td><td style="text-align:left">节点最大可用内存,默认8096M</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">yarn.nodemanager.vmem-pmem-ratio</td><td style="text-align:left">虚拟内存率，任务每使用1MB物理内存，最多可使用虚拟内存量，默认为 2.1</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">yarn.nodemanager.pmem-check-enabled</td><td style="text-align:left">是否启动一个线程检查每个任务正使用的物理内存量，如果任务超出分配值,则直接将其杀掉，默认是true</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">yarn.nodemanager.vmem-check-enabled</td><td style="text-align:left">是否启动一个线程检查每个任务正使用的虚拟内存量,如果任务超出分配值，则直接将其杀掉，默认是true</td></tr></tbody></table><p>说明:</p><ol><li>在 Centos/RHEL 6 下，由于虚拟内存的分配策略比较激进，可以调高 yarn.nodemanager.vmem-pmem-ratio 或者关闭 yarn.nodemanager.vmem-check-enabled。</li><li>不然的话有时候就会碰上抛出容器超出内存限制,然后容器被kill掉.</li><li>比如这个问题 <a href="https://stackoverflow.com/questions/21005643/container-is-running-beyond-memory-limits" target="_blank" rel="external">https://stackoverflow.com/questions/21005643/container-is-running-beyond-memory-limits</a></li></ol><h2 id="ApplicationMaster"><a href="#ApplicationMaster" class="headerlink" title="ApplicationMaster"></a>ApplicationMaster</h2><table><thead><tr><th style="text-align:left">配置参数</th><th style="text-align:left">说明</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">mapreduce.map.memory.mb</td><td style="text-align:left">分配给 Map Container的内存大小，运行时按需指定</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">mapreduce.reduce.memory.mb</td><td style="text-align:left">分配给 Reduce Container的内存大小，运行时按需指定</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">mapreduce.map.java.opts</td><td style="text-align:left">运行 Map 任务的 jvm 参数，如 -Xmx，-Xms 等选项</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">mapreduce.reduce.java.opts</td><td style="text-align:left">运行 Reduce 任务的 jvm 参数，如-Xmx，-Xms等选项</td></tr></tbody></table><h1 id="CPU资源"><a href="#CPU资源" class="headerlink" title="CPU资源"></a>CPU资源</h1><table><thead><tr><th style="text-align:left">配置参数</th><th style="text-align:left">说明</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">yarn.nodemanager.resource.cpu-vcores</td><td style="text-align:left">该节点上 YARN 可使用的虚拟 CPU 个数，默认是8</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">yarn.scheduler.minimum-allocation-vcores</td><td style="text-align:left">单个任务可申请的最小虚拟CPU个数, 默认是1</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">yarn.scheduler.maximum-allocation-vcores</td><td style="text-align:left">单个任务可申请的最多虚拟CPU个数，默认是32</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无论是mapreduce程序或者是Spark程序,提交到Yarn上来进行资源管理与分配的时候.都是运行在Yarn的Container容器中.&lt;br&gt;而Container容器中是Yarn封装的内存和CPU资源.暂时还不支持对网络IO等资源进行封装分配.那么在开发调优过程中,我们肯定无法避免会对内存进行一些分配.那么Yarn的哪些配置参数是对哪个地方进行分配的,就很重要,也就值得记一记.&lt;br&gt;
    
    </summary>
    
      <category term="yarn" scheme="http://dmlcoding.com/categories/yarn/"/>
    
    
      <category term="yarn" scheme="http://dmlcoding.com/tags/yarn/"/>
    
  </entry>
  
  <entry>
    <title>spark开发中遇到的问题</title>
    <link href="http://dmlcoding.com/2017/SparkBug/"/>
    <id>http://dmlcoding.com/2017/SparkBug/</id>
    <published>2017-08-08T02:00:00.000Z</published>
    <updated>2017-08-09T09:40:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spark连接mysql"><a href="#spark连接mysql" class="headerlink" title="spark连接mysql"></a>spark连接mysql</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">总是报no suitable driver以及   jdbc.mysql.driver类似这样的错误</div></pre></td></tr></table></figure><a id="more"></a><h2 id="解决办法1"><a href="#解决办法1" class="headerlink" title="解决办法1"></a>解决办法1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1.提交任务的时候带上这个，手动指定mysql jar包的位置</div><div class="line">                    SPARK_CLASSPATH=/usr/local/spark-1.4.1-bin-hadoop2.6/lib/mysql-connector-java-5.1.38.jar ./bin/spark-submit --class sparkDemo /root/data/demon-parent-1.0-SNAPSHOT-jar-with-dependencies.jar hdfs://192.168.119.100:9000/examples/custom.txt</div></pre></td></tr></table></figure><h2 id="解决办法2"><a href="#解决办法2" class="headerlink" title="解决办法2"></a>解决办法2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">修改了这个配置SPARK_HOME/conf/spark-env.sh文件，在里面加上了这个参数，就OK了</div><div class="line"></div><div class="line">export SPARK_CLASSPATH=$SPATH_CLASSPATH:/usr/hdp/2.4.0.0-169/spark/lib/mysql-connector-java-5.1.38.jar</div></pre></td></tr></table></figure><h1 id="在spark中使用hive抛出错误"><a href="#在spark中使用hive抛出错误" class="headerlink" title="在spark中使用hive抛出错误"></a>在spark中使用hive抛出错误</h1><h1 id="报错日志"><a href="#报错日志" class="headerlink" title="报错日志"></a>报错日志</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">17/08/09 12:11:51 WARN DataNucleus.Persistence: Error creating validator of type org.datanucleus.properties.CorePropertyValidator</div><div class="line">ClassLoaderResolver for class &quot;&quot; gave error on creation : &#123;1&#125;</div><div class="line">org.datanucleus.exceptions.NucleusUserException: ClassLoaderResolver for class &quot;&quot; gave error on creation : &#123;1&#125;</div><div class="line">at org.datanucleus.NucleusContext.getClassLoaderResolver(NucleusContext.java:1087)</div><div class="line">at org.datanucleus.PersistenceConfiguration.validatePropertyValue(PersistenceConfiguration.java:797)</div><div class="line">at org.datanucleus.PersistenceConfiguration.setProperty(PersistenceConfiguration.java:714)</div><div class="line">at org.datanucleus.PersistenceConfiguration.setPersistenceProperties(PersistenceConfiguration.java:693)</div><div class="line">at org.datanucleus.NucleusContext.&lt;init&gt;(NucleusContext.java:273)</div><div class="line">at org.datanucleus.NucleusContext.&lt;init&gt;(NucleusContext.java:247)</div><div class="line">at org.datanucleus.NucleusContext.&lt;init&gt;(NucleusContext.java:225)</div><div class="line">at org.datanucleus.api.jdo.JDOPersistenceManagerFactory.&lt;init&gt;(JDOPersistenceManagerFactory.java:416)</div><div class="line">at org.datanucleus.api.jdo.JDOPersistenceManagerFactory.createPersistenceManagerFactory(JDOPersistenceManagerFactory.java:301)</div><div class="line">at org.datanucleus.api.jdo.JDOPersistenceManagerFactory.getPersistenceManagerFactory(JDOPersistenceManagerFactory.java:202)</div></pre></td></tr></table></figure><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>看日志应该是缺少了hive的一些包,在网上搜了一下,是下面几个包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[hadoop@U007 lib]$ pwd</div><div class="line">/opt/spark-1.6.0/lib</div><div class="line">[hadoop@U007 lib]$ ll</div><div class="line">total 305220</div><div class="line">-rw-r--r-- 1 hadoop hadoop    339666 Apr 15  2016 datanucleus-api-jdo-3.2.6.jar</div><div class="line">-rw-r--r-- 1 hadoop hadoop   1890075 Apr 15  2016 datanucleus-core-3.2.10.jar</div><div class="line">-rw-r--r-- 1 hadoop hadoop   1809447 Apr 15  2016 datanucleus-rdbms-3.2.9.jar</div><div class="line">...</div></pre></td></tr></table></figure></p><p>所以在提交spark任务的时候,把这几个包加入到classpath中即可</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>在提交spark的脚本中加上这几个jar包和hive-site.xml文件<br>如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">nohup spark-submit \</div><div class="line"> --master yarn \</div><div class="line"> --deploy-mode cluster \</div><div class="line"> --class $&#123;className&#125; \</div><div class="line"> --driver-memory 4g \</div><div class="line"> --executor-memory 2g \</div><div class="line"> --executor-cores 4 \</div><div class="line"> --num-executors 4 \</div><div class="line"> --jars ./lib/datanucleus-api-jdo-3.2.6.jar,./lib/datanucleus-core-3.2.10.jar,./lib/datanucleus-rdbms</div><div class="line">-3.2.9.jar  \</div><div class="line"> --files ./lib/hive-site.xml \</div><div class="line"> ./app-jar-with-dependencies.jar \</div></pre></td></tr></table></figure></p><p>加上–jars 和 –files即可</p><h1 id="在spark中将数据插入hive动态分区"><a href="#在spark中将数据插入hive动态分区" class="headerlink" title="在spark中将数据插入hive动态分区"></a>在spark中将数据插入hive动态分区</h1><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p>当我用standalone以及yarn-client模式进行提交任务的时候,不会报错.但是当我改成yarn-cluster模式进行提交任务,有时候就会报下面的错</p><h2 id="报错日志-1"><a href="#报错日志-1" class="headerlink" title="报错日志"></a>报错日志</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">17/08/09 10:08:01 ERROR scheduler.JobScheduler: Error running job streaming job 1502188440000 ms.0</div><div class="line">java.lang.NoSuchMethodException: org.apache.hadoop.hive.ql.metadata.Hive.loadDynamicPartitions(org.apache.hadoop.fs.Path, java.lang.String, java.util.Map, boolean, int, boolean, boolean)</div><div class="line">at java.lang.Class.getMethod(Class.java:1670)</div><div class="line">at org.apache.spark.sql.hive.client.Shim.findMethod(HiveShim.scala:114)</div><div class="line">at org.apache.spark.sql.hive.client.Shim_v0_12.loadDynamicPartitionsMethod$lzycompute(HiveShim.scala:168)</div><div class="line">at org.apache.spark.sql.hive.client.Shim_v0_12.loadDynamicPartitionsMethod(HiveShim.scala:167)</div><div class="line">at org.apache.spark.sql.hive.client.Shim_v0_12.loadDynamicPartitions(HiveShim.scala:261)</div><div class="line">at org.apache.spark.sql.hive.client.ClientWrapper$$anonfun$loadDynamicPartitions$1.apply$mcV$sp(ClientWrapper.scala:560)</div><div class="line">at org.apache.spark.sql.hive.client.ClientWrapper$$anonfun$loadDynamicPartitions$1.apply(ClientWrapper.scala:560)</div><div class="line">at org.apache.spark.sql.hive.client.ClientWrapper$$anonfun$loadDynamicPartitions$1.apply(ClientWrapper.scala:560)</div><div class="line">at org.apache.spark.sql.hive.client.ClientWrapper$$anonfun$withHiveState$1.apply(ClientWrapper.scala:279)</div><div class="line">at org.apache.spark.sql.hive.client.ClientWrapper.liftedTree1$1(ClientWrapper.scala:226)</div><div class="line">at org.apache.spark.sql.hive.client.ClientWrapper.retryLocked(ClientWrapper.scala:225)</div><div class="line">at org.apache.spark.sql.hive.client.ClientWrapper.withHiveState(ClientWrapper.scala:268)</div><div class="line">at org.apache.spark.sql.hive.client.ClientWrapper.loadDynamicPartitions(ClientWrapper.scala:559)</div><div class="line">at org.apache.spark.sql.hive.execution.InsertIntoHiveTable.sideEffectResult$lzycompute(InsertIntoHiveTable.scala:225)</div><div class="line">at org.apache.spark.sql.hive.execution.InsertIntoHiveTable.sideEffectResult(InsertIntoHiveTable.scala:127)</div><div class="line">at org.apache.spark.sql.hive.execution.InsertIntoHiveTable.doExecute(InsertIntoHiveTable.scala:276)</div><div class="line">at org.apache.spark.sql.execution.SparkPlan$$anonfun$execute$5.apply(SparkPlan.scala:132)</div><div class="line">at org.apache.spark.sql.execution.SparkPlan$$anonfun$execute$5.apply(SparkPlan.scala:130)</div><div class="line">at org.apache.spark.rdd.RDDOperationScope$.withScope(RDDOperationScope.scala:150)</div><div class="line">at org.apache.spark.sql.execution.SparkPlan.execute(SparkPlan.scala:130)</div><div class="line">at org.apache.spark.sql.execution.QueryExecution.toRdd$lzycompute(QueryExecution.scala:55)</div><div class="line">at org.apache.spark.sql.execution.QueryExecution.toRdd(QueryExecution.scala:55)</div><div class="line">at org.apache.spark.sql.DataFrame.&lt;init&gt;(DataFrame.scala:145)</div><div class="line">at org.apache.spark.sql.DataFrame.&lt;init&gt;(DataFrame.scala:130)</div><div class="line">at org.apache.spark.sql.DataFrame$.apply(DataFrame.scala:52)</div><div class="line">at org.apache.spark.sql.SQLContext.sql(SQLContext.scala:817)</div></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>用client模式的时候,是在13上运行的.没有问题<br>用cluster模式的时候,有时候报错,有时候没有报错<br>那不禁让我猜想,为啥cluster模式时而报错时而不报错呢?</p><p>然后我用client模式,在14上提交,不出我所料,基本上每个job都抛出了那个错误.<br>所以定位到问题就是,除了13这个节点外,别的节点缺少了什么包,导致抛出了错误.<br>因为抛出来的错误是java.lang.NoSuchMethodException:,所以肯定是缺少了什么包.<br>之前cluster模式时而报错时而不报错的原因肯定是,当不报错的时候,正好driver端是在13上</p><p>现在的问题就是找出别的机器缺少什么包了.</p><p>然后我在spark的环境变量里面发现了这个参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">spark.sql.hive.metastore.jars :/usr/lib/hive/lib/*:/opt/spark-1.6.0/lib/spark-assembly-1.6.0-hadoop2.4.0.jar</div></pre></td></tr></table></figure></p><p>我去,13上有这个/usr/lib/hive/lib/* 路径<br>14和15上都没有,,,<br>问题找到了</p><h2 id="解决办法1-1"><a href="#解决办法1-1" class="headerlink" title="解决办法1"></a>解决办法1</h2><p>把13上这个路径/usr/lib/hive/lib/* 拷贝到14和15上,各自都有一份.这样无论driver端在哪里,都能找到相应的jar包.<br>就这样愉快的解决了.<br>所以遇到问题,慢慢分析,不要像无头苍蝇一样.<br>在网上搜的解决办法,都无法解决这个问题.所以有时候,具体问题具体分析,要慢慢的分析到出错原因.找到了原因,bug就能迎刃而解.</p><h2 id="解决办法2-1"><a href="#解决办法2-1" class="headerlink" title="解决办法2"></a>解决办法2</h2><p>在spark的配置文件中把 <code>spark.sql.hive.metastore.jars</code> 给删了.因为你总不能在每个节点上去拷贝hive的一些依赖吧,如果以后hive升级了,还得替换hive的jar包,太麻烦.所以改成下面的解决办法更好.</p><p>在pom文件中加上hive的依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">&lt;!-- https://mvnrepository.com/artifact/org.apache.spark/spark-core_2.10 --&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spark-core_2.10&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.6.0&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;!-- https://mvnrepository.com/artifact/org.apache.spark/spark-mllib_2.10 --&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spark-mllib_2.10&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.6.0&lt;/version&gt;</div><div class="line">    &lt;scope&gt;provided&lt;/scope&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line"></div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spark-streaming_2.10&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.6.0&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spark-streaming-kafka_2.10&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.6.0&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spark-sql_2.10&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.6.0&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spark-hive_2.10&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.6.0&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;5.1.32&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.apache.hive&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;hive-jdbc&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;0.13.1&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;!-- https://mvnrepository.com/artifact/org.apache.hive/hive-exec --&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.apache.hive&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;hive-exec&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;0.13.1&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;spark连接mysql&quot;&gt;&lt;a href=&quot;#spark连接mysql&quot; class=&quot;headerlink&quot; title=&quot;spark连接mysql&quot;&gt;&lt;/a&gt;spark连接mysql&lt;/h1&gt;&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;总是报no suitable driver以及   jdbc.mysql.driver类似这样的错误&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="spark" scheme="http://dmlcoding.com/categories/spark/"/>
    
    
      <category term="spark" scheme="http://dmlcoding.com/tags/spark/"/>
    
      <category term="mysql" scheme="http://dmlcoding.com/tags/mysql/"/>
    
      <category term="hive" scheme="http://dmlcoding.com/tags/hive/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java虚拟机之JDK可视化工具(二)</title>
    <link href="http://dmlcoding.com/2017/JDKOrderConsole/"/>
    <id>http://dmlcoding.com/2017/JDKOrderConsole/</id>
    <published>2017-08-06T12:00:00.000Z</published>
    <updated>2017-08-09T04:23:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>除了JDK命令行工具,还有几个很强大的JDK可视化工具,希望接下来的学习,可以提高我们解决bug的能力<br><a id="more"></a></p><h1 id="JConsole-Java监视与管理控制台"><a href="#JConsole-Java监视与管理控制台" class="headerlink" title="JConsole:Java监视与管理控制台"></a>JConsole:Java监视与管理控制台</h1><blockquote><p>JConsole(Java Monitoring and Management Console)<br>JConsole是在JDK1.5时期就已经提供的虚拟机监控工具<br>JConsole是一款基于JMX的可视化监视和管理工具,它管理部分的功能是针对JMX MBean进行管理.</p></blockquote><h2 id="启动JConsole"><a href="#启动JConsole" class="headerlink" title="启动JConsole"></a>启动JConsole</h2><ul><li>1.安装的bin目录下执行<code>jconsole</code></li><li>2.如果配置了 <strong>JAVA_HOME</strong> 直接输入<code>jconsole</code></li></ul><p>Jconsole启动后,会自动搜索出本机运行的所有虚拟机进程,不需要用户再使用jps来查询了,如下图所示,双击选择其中一个进程即可开始监控.当然也可以使用 <em>远程进程</em> 功能来连接远程服务器,对远程虚拟机进行监控<br><img src="/images/jdk/jconsole1.png" alt="jconsole1"></p><p>栈内存     堆内存<br>-Xms100m -Xmx100m -XX:+UseSerialGC</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;除了JDK命令行工具,还有几个很强大的JDK可视化工具,希望接下来的学习,可以提高我们解决bug的能力&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://dmlcoding.com/categories/java/"/>
    
    
      <category term="java" scheme="http://dmlcoding.com/tags/java/"/>
    
      <category term="jdk" scheme="http://dmlcoding.com/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java虚拟机之Java内存区域与内存溢出</title>
    <link href="http://dmlcoding.com/2017/JDKMemory/"/>
    <id>http://dmlcoding.com/2017/JDKMemory/</id>
    <published>2017-08-03T08:00:00.000Z</published>
    <updated>2017-08-07T01:23:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于java程序员来说,虽然有虚拟机的自动内存管理机制,我们即使不清楚内存是如何分配的,也不妨碍我们写代码.但是如果你不明白虚拟机究竟做了啥,你既不能快速定位问题,也不能成为一个优秀的程序员.</p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>对于java程序员来说,在虚拟机的自动内存管理机制的帮助下,不再需要为每一个new操作去写配对的delete/free代码(C/C++语言是需要的),而且不容易出现内存泄漏和内存溢出问题,看起来由虚拟机管理内存一切都很美好.不过,也正是因为java程序员把内存控制的权利交给了Java虚拟机,一旦出现内存泄露和溢出方面的问题,如果不了解虚拟机是怎样使用内存的,那排查错误将会成为一项异常艰难的工作.<br>在这篇文章里,我们会写到这几个部分,了解了这几个部分,也就可以翻越虚拟机内存管理的第一步.</p><ul><li>java虚拟机内存的各个区域</li><li>各个区域的作用,服务对象,以及其中可能产生的问题</li></ul><h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><ul><li>Java虚拟机在执行Java程序的过程中,会把它管理的内存划分为若干个不同的数据区域.</li><li>这些区域都有各自的用途,以及创建和销毁的时间,有的区域随着虚拟机进程的启动而存在,有些区域则是依赖用户线程的启动和结束而建立和销毁.<br><strong>根据Java虚拟机规范规定,Java虚拟机所管理的内存将会包括以下几个运行时数据区域</strong><br><img src="/images/jdk/jdkquyu.png" alt="java运行时区域"><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><blockquote><p>程序计数器(Program Counter Register)是一块较小的内存空间,它的作用可以看做是当前线程所执行的字节码的行号指示器.</p></blockquote></li></ul><p>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令,分支,循环,跳转,异常处理,线程恢复等基础功能都需要依赖这个计数器来完成.(想想我们平时写的java代码,是不是感觉一切都是有原因的)</p><p>对于多线程来说.由于每个线程都会执行自己的指令.那么为了线程切换后能恢复到正确的执行位置,因此每条线程都需要有一个独立的程序计数器,这样每条线程之间的计数器互不影响,独立存储.我们称这类内存区域称为 <strong>线程私有</strong> 的内存.</p><h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><blockquote><p>与程序计数器一样,Java虚拟机栈(Java Virtual Machine Stacks)也是线程私有的.它的生命周期与线程相同.</p></blockquote><p>我们平时所说的栈内存,也就是这里的虚拟机栈.那么这个虚拟机栈究竟是什么呢?<br>虚拟机栈描述的是java方法执行的内存模型:</p><ul><li>每个方法被执行的时候都会同时创建一个 <strong>栈帧(Stack Frame)</strong> 用于存储<code>局部变量表</code>,<code>操作栈</code>,<code>动态链接</code>,<code>方法出口</code>等信息.</li><li>每一个方法被调用直至执行完成的过程,就对应着一个 <strong>栈帧</strong> 在虚拟机栈中从入栈到出栈的过程.</li></ul><p>提一下局部变量表:</p><ul><li>局部变量表存放了编译期可知的各种基本数据类型(boolean,byte,char,short,int,float,long,double),对象引用(reference类型,它不等同于对象本身).</li><li>局部变量表所需的内存空间在编译期间完成分配,当进入一个方法时,这个方法需要在帧中分配多大的局部变量空间是完全确定的,在方法运行期间不会改变局部变量表的大小.</li><li>局部变量表区域可能会抛出两种异常状况<ul><li>如果线程请求的栈深度大于虚拟机所允许的深度,将抛出StackOverflowError异常.</li><li>如果虚拟机可以动态扩展,当扩展时无法申请到足够的内存时会抛出OutOfMemoryError.</li></ul></li></ul><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><ul><li>本地方法栈(Native Method Stacks)与虚拟机所发挥的作用是非常相似的</li><li>本地方法栈与虚拟机栈的区别<ul><li>虚拟机栈为虚拟机执行Java方法(也就是字节码)服务</li><li>本地方法栈则是为虚拟机使用到的Native方法服务</li></ul></li><li>有些虚拟机(譬如Sun HotSpot)直接就把本地方法栈和虚拟机栈合二为一</li></ul><p>关于什么是Native方法呢?<br>参考:<a href="http://blog.csdn.net/wike163/article/details/6635321" target="_blank" rel="external">http://blog.csdn.net/wike163/article/details/6635321</a></p><h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p><strong>堆内存的特点</strong></p><ul><li>对于大多数应用来说,Java堆(Java heap)是Java虚拟机所管理的内存中最大的一块.</li><li>Java堆是被所有线程共享的一块内存区域,<strong>在虚拟机启动时创建</strong> .</li><li>Java堆内存区域的唯一目的就是存放对象实例,几乎所有的对象实例都是在这里分配内存.</li><li>Java堆是垃圾收集器管理的主要区域.因为那么多实例在堆上分配内存,实例用完后,我们肯定要及时回收内存,这样才能给新的实例分配足够的内存呢.</li><li>Java堆可以处于物理上不连续的内存空间中,只要逻辑上是连续的即可,就像我们的磁盘空间一样.</li><li>如果在堆中没有内存完成实例分配,并且堆也无法再扩展时,将会抛出OutOfMemoryErrory异常.</li></ul><p><strong>再细分一下堆内存</strong></p><ul><li>从垃圾回收的角度看<ul><li>因为现在的垃圾收集器都是采用分代收集算法,所以Java堆中还可以细分为:<code>新生代</code>,<code>老年代</code>,等等区域.</li><li>后面写到垃圾回收的时候,再细说这部分.</li></ul></li><li>从内存分配的角度看<ul><li>线程共享的Java堆中可能划分出多个线程私有的分配缓存区</li></ul></li><li>在实现上<ul><li>既可以实现成固定大小的,也可以是扩展的.</li><li>不过目前主流的虚拟机都是按照可扩展来实现的</li><li><code>-Xmx</code>来设置程序的堆内存大小</li><li><code>-Xms</code>来设置程序的栈内存大小</li></ul></li></ul><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><blockquote><p>方法区(Method Area)<br><strong>方法区的特点</strong></p><ul><li>方法区与Java堆一样,是各个线程共享的内存区域.</li><li>它用于存储已被虚拟机加载的类信息,常量,静态变量,即时编译器编译后的代码等数据.</li><li>然后Java虚拟机规范把方法区描述为堆的一个逻辑部分,但是它却有一个别名叫做Non-Heap(非堆),目的应该是与Java堆区分开来.</li><li>方法区被有些人称为”永久代(Permanent Generation)”是因为GC分代收集时候,方法区的变量会在永久代区域.</li><li>当方法区无法满足内存分区需求时,将抛出OutOfMemoryErrory异常.</li></ul></blockquote><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池是方法区的一部分.Class文件中除了有类的版本,字段,方法,接口等描述信息外,还有一项信息是 <strong>常量池(Constant Pool Table)</strong>.<br>用于存放编译期生成的各种字面量和符号引用,这部分内容将在类加载后存放到方法区的运行时常量池中.</p><p>Java语言并不要求常量一定只能在编译器产生,也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池,运行期间也可能将新的常量放入池中.</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分,也不是Java虚拟机规范中定义的内存区域,但是这部分内存也被频繁地使用,而且也可能导致OutOfMemoryErrory异常.那么究竟什么是直接内存呢?</p><p>在JDK1.4中新加入了NIO(New Input/Output)类,引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式,它可以使用Native函数库直接分配堆外内存,然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作.</p><p>这样能在一些场景中显著提高性能,因为避免了在Java堆和Native堆中来回复制数据.</p><h1 id="对象访问-问题-在Java语言中-对象访问是如何进行的"><a href="#对象访问-问题-在Java语言中-对象访问是如何进行的" class="headerlink" title="对象访问(问题:在Java语言中,对象访问是如何进行的?)"></a>对象访问(问题:在Java语言中,对象访问是如何进行的?)</h1><blockquote><p>对象访问在java语言中无处不在,是最普通的程序行为,但即使是最简单的访问,也会涉及Java栈,Java堆,方法区这三个最重要内存区域之间的关联关系.<br>上面简单介绍了Java虚拟机的运行时数据区.说得比较文字化,不够具体.那么我们具体来探讨一个问题.<br><strong>在Java语言中,对象访问是如何进行的?</strong></p></blockquote><p>看这行最简单的代码,我们来解释这行代码.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object obj=new Object();</div></pre></td></tr></table></figure></p><p>假设这句代码出现在方法体中,那么</p><ul><li><strong>Object obj</strong> 这部分的语义将会反映到 <strong>Java栈的本地变量表</strong> 中,作为一个reference类型数据出现.</li><li><strong>new Object()</strong> 这部分的语义将会反映到 <strong>Java堆</strong> 中,形成一块存储了Object类型所有实例数据值的结构化内存.<ul><li>这块内存的长度是不固定</li><li>另外,在这个堆中还必须包含能查找到此对象类型数据(如对象类型,父类,实现的接口,方法等)的地址信息,这些类型数据则存储在方法区.</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于java程序员来说,虽然有虚拟机的自动内存管理机制,我们即使不清楚内存是如何分配的,也不妨碍我们写代码.但是如果你不明白虚拟机究竟做了啥,你既不能快速定位问题,也不能成为一个优秀的程序员.&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://dmlcoding.com/categories/java/"/>
    
    
      <category term="java" scheme="http://dmlcoding.com/tags/java/"/>
    
      <category term="jdk" scheme="http://dmlcoding.com/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java虚拟机之JDK命令行工具(一)</title>
    <link href="http://dmlcoding.com/2017/JDKOrder/"/>
    <id>http://dmlcoding.com/2017/JDKOrder/</id>
    <published>2017-08-02T12:00:00.000Z</published>
    <updated>2017-08-09T02:55:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>JDK命令行工具,是java提供给我们的礼物,我们怎么能拒绝他们的馈赠呢</p><a id="more"></a><h1 id="jps-虚拟机进程状况工具"><a href="#jps-虚拟机进程状况工具" class="headerlink" title="jps:虚拟机进程状况工具"></a>jps:虚拟机进程状况工具</h1><blockquote><p>jps(JVM Process Status)<br>可以列出正在运行的虚拟机进程,,并显示虚拟机执行主类(main函数的名称),以及这些进程的本地虚拟机的唯一ID(LVMID,Local Virtual Machine Identifier)<br>对于本地虚拟机进程来说,LVMID与操作系统的进程ID(PID,Process Identifier)是一致的</p></blockquote><h2 id="jps命令格式"><a href="#jps命令格式" class="headerlink" title="jps命令格式"></a>jps命令格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jps [options] [hostid]</div></pre></td></tr></table></figure><h2 id="jps工具主要选项"><a href="#jps工具主要选项" class="headerlink" title="jps工具主要选项"></a>jps工具主要选项</h2><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:center">-q</td><td style="text-align:left">只输出LVMID,省略主类的名称</td></tr><tr><td style="text-align:center">-m</td><td style="text-align:left">输出虚拟机进程启动时传递给主类main()函数的参数</td></tr><tr><td style="text-align:center">-l</td><td style="text-align:left">输出主类的全名,如果进程执行的是jar包,输出jar路径</td></tr><tr><td style="text-align:center">-v</td><td style="text-align:left">输出虚拟机进程启动时JVM参数</td></tr></tbody></table><h2 id="jps命令样例1"><a href="#jps命令样例1" class="headerlink" title="jps命令样例1"></a>jps命令样例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[hadoop@U006 ~]$ jps -l</div><div class="line">3183 sun.tools.jps.Jps</div><div class="line">17831 org.apache.spark.executor.CoarseGrainedExecutorBackend</div><div class="line">10004 org.apache.spark.deploy.worker.Worker</div><div class="line">17659 org.apache.spark.deploy.SparkSubmit</div><div class="line">10254 org.apache.spark.deploy.worker.Worker</div><div class="line">9830 org.apache.spark.deploy.master.Master</div></pre></td></tr></table></figure><h1 id="jstat-虚拟机统计信息监视工具"><a href="#jstat-虚拟机统计信息监视工具" class="headerlink" title="jstat:虚拟机统计信息监视工具"></a>jstat:虚拟机统计信息监视工具</h1><blockquote><p>jstat(JVM Statistics Monitoring Tool)<br>jstat是用于监视虚拟机各种运行状态信息的命令行工具<br>它可以显示本地或远程虚拟机进程中的类装载,内存,垃圾收集,JIT编译等运行数据.<br>在没有GUI图形界面,只提供了纯文本控制台环境的服务器上,它将是运行期定位虚拟机性能问题的首选工具</p></blockquote><h2 id="jstat命令格式"><a href="#jstat命令格式" class="headerlink" title="jstat命令格式"></a>jstat命令格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jstat [option vmid [interval[s|ms] [count]]]</div></pre></td></tr></table></figure><p><strong>注意</strong>:</p><ul><li>对于命令中的VMID与LVMID需要特别说明一下:如果是本地虚拟机进程,VMID与LVMID是一致的.</li><li>如何是远程虚拟机进程,那VMID的格式应当是:<code>[protocal:][//]lvmid[@hostname[:port]/servername]</code></li><li>参数interval和count代表查询间隔和次数.如果省略这两个参数,说明只查询一次.</li></ul><p>假设需要每250毫秒查询一次进程2764垃圾收集的状况,一共查询20次,那么命令应该是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jstat -gc 2764 250 20</div></pre></td></tr></table></figure></p><p>每2毫秒查询10次spark进程的垃圾收集状况:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[hadoop@U006 ~]$ jstat -gc 17659 2 10</div><div class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       PC     PU    YGC     YGCT    FGC    FGCT     GCT</div><div class="line">349184.0 349184.0  0.0    0.0   2098176.0 954275.3 5592576.0   246723.4  116224.0 115802.6     52    5.099  48     18.956   24.056</div><div class="line">349184.0 349184.0  0.0    0.0   2098176.0 954275.3 5592576.0   246723.4  116224.0 115802.6     52    5.099  48     18.956   24.056</div><div class="line">349184.0 349184.0  0.0    0.0   2098176.0 954275.3 5592576.0   246723.4  116224.0 115802.6     52    5.099  48     18.956   24.056</div><div class="line">349184.0 349184.0  0.0    0.0   2098176.0 954275.3 5592576.0   246723.4  116224.0 115802.6     52    5.099  48     18.956   24.056</div><div class="line">349184.0 349184.0  0.0    0.0   2098176.0 954275.3 5592576.0   246723.4  116224.0 115802.6     52    5.099  48     18.956   24.056</div><div class="line">349184.0 349184.0  0.0    0.0   2098176.0 954275.3 5592576.0   246723.4  116224.0 115802.6     52    5.099  48     18.956   24.056</div><div class="line">349184.0 349184.0  0.0    0.0   2098176.0 954275.3 5592576.0   246723.4  116224.0 115802.6     52    5.099  48     18.956   24.056</div><div class="line">349184.0 349184.0  0.0    0.0   2098176.0 954275.3 5592576.0   246723.4  116224.0 115802.6     52    5.099  48     18.956   24.056</div><div class="line">349184.0 349184.0  0.0    0.0   2098176.0 954275.3 5592576.0   246723.4  116224.0 115802.6     52    5.099  48     18.956   24.056</div><div class="line">349184.0 349184.0  0.0    0.0   2098176.0 954275.3 5592576.0   246723.4  116224.0 115802.6     52    5.099  48     18.956   24.056</div></pre></td></tr></table></figure></p><h2 id="jstat工具主要选项"><a href="#jstat工具主要选项" class="headerlink" title="jstat工具主要选项"></a>jstat工具主要选项</h2><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:center">-class</td><td style="text-align:left">监视类装载,卸载数据,总空间及类装载所耗费的时间</td></tr><tr><td style="text-align:center">-gc</td><td style="text-align:left">监视Java堆状况,包括Eden区,2个survivor区,老年代,永久代等的容量,已用空间,GC时间合计等信息</td></tr><tr><td style="text-align:center">-gccapacity</td><td style="text-align:left">监视内容与-gc基本相同,但输出主要关注Java堆各个区域使用到的最大和最小空间</td></tr><tr><td style="text-align:center">-gcutil</td><td style="text-align:left">监视内容与-gc基本相同,但输出主要关注已使用空间占总空间的百分比</td></tr><tr><td style="text-align:center">…</td><td style="text-align:left">…</td></tr></tbody></table><h2 id="jstat执行样例"><a href="#jstat执行样例" class="headerlink" title="jstat执行样例"></a>jstat执行样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hadoop@U006 ~]$ jstat -gcutil 17659</div><div class="line">  S0     S1     E      O      P     YGC     YGCT    FGC    FGCT     GCT</div><div class="line">  0.00   0.00  37.59   4.41  99.68     77    7.439    73   27.473   34.912</div></pre></td></tr></table></figure><p>查询结果表明:<br>这个进程的</p><ul><li>新生代Eden区(E,表示Eden)使用了37.59%的空间.</li><li>两个Survivor区(S0,S1,表示Survivor0,Survivor1)里面都是空的.</li><li>老年代(O,表示Old)和永久代(P,表示Permanent)则分别使用了4.41%和99.68%的空间.</li><li>程序运行以来共发生Minor GC(YGC,表示Young GC)77次,总耗时7.439秒.</li><li>发生Full GC(FGC,表示Full GC)73次,Full GC总耗时(FGCT,表示Full GC Time)为27.473秒.</li><li>所有GC总耗时(GCT,表示GC Time)为34.912秒.</li></ul><p><strong>总结</strong>:使用jstat工具在纯文本状态下监视虚拟机状态的变化,虽然没有一些可视化监控工具来得直观.但与我而言,更显极客本色.</p><h1 id="jinfo-Java配置信息工具"><a href="#jinfo-Java配置信息工具" class="headerlink" title="jinfo:Java配置信息工具"></a>jinfo:Java配置信息工具</h1><blockquote><p>jinso(Configuration Info For Java)<br>jinfo的作用是实时地查看和调整虚拟机的各项参数</p></blockquote><h2 id="jinfo命令格式"><a href="#jinfo命令格式" class="headerlink" title="jinfo命令格式"></a>jinfo命令格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jinfo [option] pid</div></pre></td></tr></table></figure><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>前面解释过jps的-v选项.这个可以查看虚拟机启动时显示指定的参数列表,比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[hadoop@U006 ~]$ jps -v</div><div class="line">17831 CoarseGrainedExecutorBackend -Xms4096M -Xmx4096M -Dspark.driver.port=42195 -XX:MaxPermSize=256m</div><div class="line">5146 Jps -Dapplication.home=/usr/java/jdk1.7.0_71 -Xms8m</div><div class="line">10004 Worker -Xms1g -Xmx1g -XX:MaxPermSize=256m</div><div class="line">17659 SparkSubmit -Xms8g -Xmx8g -XX:MaxPermSize=256m</div><div class="line">10254 Worker -Xms1g -Xmx1g -XX:MaxPermSize=256m</div><div class="line">9830 Master -Xms1g -Xmx1g -XX:MaxPermSize=256m</div></pre></td></tr></table></figure></p><p>但如果想知道未被显示指定的参数的系统默认值,除了查找资料,还可以使用这里的<code>jinfo的-flag</code>选项进行查询了.</p><p>比如查询CMSInitiatingOccupancyFraction参数值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[hadoop@U006 ~]$ jinfo -flag CMSInitiatingOccupancyFraction 17659</div><div class="line">-XX:CMSInitiatingOccupancyFraction=-1</div></pre></td></tr></table></figure></p><h1 id="jmap-Java内存映像工具"><a href="#jmap-Java内存映像工具" class="headerlink" title="jmap:Java内存映像工具"></a>jmap:Java内存映像工具</h1><blockquote><p>jmap(Memory Map For Java)<br>jmap是用于生成堆转储快照(一般称为Heapdump或dump文件).</p></blockquote><h1 id="jstack-Java堆栈跟踪工具"><a href="#jstack-Java堆栈跟踪工具" class="headerlink" title="jstack:Java堆栈跟踪工具"></a>jstack:Java堆栈跟踪工具</h1><blockquote><p>jstack(Stack Trace for Java)<br>jstack命令用于生成虚拟机当前时刻的线程快照(一般称为threaddump或javacore文件)</p></blockquote><p><strong>线程快照:</strong> 就是当前虚拟机内每一条线程正在执行的方法堆栈的集合,生成线程快照的主要目的是 <em>定位线程出现长时间停顿的原因</em>.</p><p>线程长时间停顿的常见原因:<br>1.线程间死锁,死循环<br>2.请求外部资源导致的长时间等待<br>3.等等</p><p>线程出现停顿的时候通过jstack来查看各个线程的调用堆栈,就可以知道没有响应的线程到底在后台做些什么事情,或者等待着什么资源.</p><h2 id="jstack命令格式"><a href="#jstack命令格式" class="headerlink" title="jstack命令格式"></a>jstack命令格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jstack [option] vmid</div></pre></td></tr></table></figure><h2 id="jstack工具的主要选项"><a href="#jstack工具的主要选项" class="headerlink" title="jstack工具的主要选项"></a>jstack工具的主要选项</h2><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:center">-F</td><td style="text-align:left">当正常输出的请求不被响应时,强制输出线程堆栈</td></tr><tr><td style="text-align:center">-l</td><td style="text-align:left">除堆栈外,显示关于锁的附加信息</td></tr><tr><td style="text-align:center">-m</td><td style="text-align:left">如果调用到本地方法的话,可以显示C/C++的堆栈</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JDK命令行工具,是java提供给我们的礼物,我们怎么能拒绝他们的馈赠呢&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://dmlcoding.com/categories/java/"/>
    
    
      <category term="java" scheme="http://dmlcoding.com/tags/java/"/>
    
      <category term="jdk" scheme="http://dmlcoding.com/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>机器视觉处理与Tesseract介绍</title>
    <link href="http://dmlcoding.com/2017/TesseractBasic/"/>
    <id>http://dmlcoding.com/2017/TesseractBasic/</id>
    <published>2017-07-27T01:23:46.000Z</published>
    <updated>2017-07-27T01:44:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在读取和处理图像、图像相关的机器学习以及创建图像等任务中，Python 一直都是非常出色的语言。虽然有很多库可以进行图像处理，但目前我只接触到Tesseract.</p><a id="more"></a><h1 id="Tesseract"><a href="#Tesseract" class="headerlink" title="Tesseract"></a>Tesseract</h1><p>Tesseract 是一个 OCR 库,目前由 Google 赞助(Google 也是一家以 OCR 和机器学习技术闻名于世的公司)。Tesseract 是目前公认最优秀、最精确的开源 OCR 系统。 除了极高的精确度,Tesseract 也具有很高的灵活性。它可以通过训练识别出任何字体，也可以识别出任何 Unicode 字符。</p><h1 id="安装Tesseract"><a href="#安装Tesseract" class="headerlink" title="安装Tesseract"></a>安装Tesseract</h1><h2 id="Windows-系统"><a href="#Windows-系统" class="headerlink" title="Windows 系统"></a>Windows 系统</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">下载可执行安装文件https://code.google.com/p/tesseract-ocr/downloads/list安装。</div></pre></td></tr></table></figure><h2 id="Linux-系统"><a href="#Linux-系统" class="headerlink" title="Linux 系统"></a>Linux 系统</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">可以通过 apt-get 安装: $sudo apt-get tesseract-ocr</div></pre></td></tr></table></figure><h2 id="Mac-OS-X系统"><a href="#Mac-OS-X系统" class="headerlink" title="Mac OS X系统"></a>Mac OS X系统</h2><p>用 Homebrew(<a href="http://brew.sh/)等第三方库可以很方便地安装" target="_blank" rel="external">http://brew.sh/)等第三方库可以很方便地安装</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install tesseract</div></pre></td></tr></table></figure></p><p>要使用 Tesseract 的功能，比如后面的示例中训练程序识别字母，要先在系统中设置一个新的环境变量 $TESSDATA_PREFIX，让 Tesseract 知道训练的数据文件存储在哪里，然后搞一份tessdata数据文件，放到Tesseract目录下。</p><p>在大多数 Linux 系统和 Mac OS X 系统上,你可以这么设置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$export TESSDATA_PREFIX=/usr/local/share/Tesseract</div></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">hushiwei@localhost  ~  more ~/.bash_profile</div><div class="line">alias l=&apos;ls -lF&apos;</div><div class="line">alias ll=&apos;ls -alF&apos;</div><div class="line">JAVA_HOME=`/usr/libexec/java_home`</div><div class="line">SCALA_HOME=/Users/hushiwei/devApps/scala-2.10.5</div><div class="line">MAVEN_HOME=/Users/hushiwei/devApps/maven-3.3.9</div><div class="line">TESSDATA_PREFIX=/Users/hushiwei/devApps/Tesseract</div></pre></td></tr></table></figure></p><p>在 Windows 系统上也类似,你可以通过下面这行命令设置环境变量:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#setx TESSDATA_PREFIX C:\Program Files\Tesseract OCR\Tesseract</div></pre></td></tr></table></figure></p><h1 id="安装pytesseract"><a href="#安装pytesseract" class="headerlink" title="安装pytesseract"></a>安装pytesseract</h1><p>Tesseract 是一个 Python 的命令行工具，不是通过 import 语句导入的库。安装之后,要用 tesseract 命令在 Python 的外面运行，但我们可以通过 pip 安装支持Python 版本的 Tesseract库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install pytesseract</div></pre></td></tr></table></figure></p><h1 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h1><p>目前只能处理规范的文字,那么什么算<code>格式规范</code>呢?<br>格式规范的文字具有以下特点:</p><ul><li>使用一个标准字体(不包含手写体、草书,或者十分“花哨的”字体) • 虽然被复印或拍照,字体还是很清晰,没有多余的痕迹或污点</li><li>排列整齐,没有歪歪斜斜的字</li><li>没有超出图片范围,也没有残缺不全,或紧紧贴在图片的边缘</li></ul><p>格式规范的图片示例<br><img src="/images/python/test.png" alt="test图片"></p><h2 id="命令行方式"><a href="#命令行方式" class="headerlink" title="命令行方式"></a>命令行方式</h2><p>那么试一试Tesseract,,看看效果如何.用起来也是非常简单.读取图片,然后把结果写入到一个文本文件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hushiwei@localhost  ~/Desktop  tesseract test.png text</div><div class="line">Tesseract Open Source OCR Engine v3.05.01 with Leptonica</div><div class="line">Warning. Invalid resolution 0 dpi. Using 70 instead.</div></pre></td></tr></table></figure></p><p>接着打开这个文本看看效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hushiwei@localhost  ~/Desktop  more text.txt</div><div class="line">This is some text, written in Arial, that will be read by</div><div class="line">Tesseract. Here are some symbols: !@#$%&quot;&amp;&apos;()</div></pre></td></tr></table></figure></p><p>除了一个小符号没有识别出来,其他的字符基本上都识别对了.</p><h2 id="python代码方式进行识别"><a href="#python代码方式进行识别" class="headerlink" title="python代码方式进行识别"></a>python代码方式进行识别</h2><p>用之前安装的<code>pytesseract</code>模块,就可以很方便的完成我们想要的效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import pytesseract</div><div class="line"></div><div class="line">from PIL import Image</div><div class="line"></div><div class="line"># 打开一个图片</div><div class="line">image=Image.open(&apos;test.png&apos;)</div><div class="line"></div><div class="line"># 调用pytesseract的image_to_string方法识别出图片中的文字,返回识别出来的文字</div><div class="line">text=pytesseract.image_to_string(image)</div><div class="line"></div><div class="line"># 打印文字看看效果</div><div class="line">print text</div></pre></td></tr></table></figure><p>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">This is some text, written in Arial, that will be read by</div><div class="line">Tesseract. Here are some symbols: !@#$%&quot;&amp;&apos;()</div><div class="line"></div><div class="line">Process finished with exit code 0</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在读取和处理图像、图像相关的机器学习以及创建图像等任务中，Python 一直都是非常出色的语言。虽然有很多库可以进行图像处理，但目前我只接触到Tesseract.&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://dmlcoding.com/categories/python/"/>
    
    
      <category term="python" scheme="http://dmlcoding.com/tags/python/"/>
    
      <category term="tesseract" scheme="http://dmlcoding.com/tags/tesseract/"/>
    
  </entry>
  
  <entry>
    <title>python 可视化包-Matplotlib</title>
    <link href="http://dmlcoding.com/2017/MatplotlibBasic/"/>
    <id>http://dmlcoding.com/2017/MatplotlibBasic/</id>
    <published>2017-07-26T15:24:00.000Z</published>
    <updated>2017-07-27T06:53:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>Matplotlib是Python中最常用的可视化工具之一，可以非常方便地创建海量类型地2D图表和一些基本的3D图表。</p><a id="more"></a><h1 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># ubuntu上安装</div><div class="line">sudo apt install python-matplotlib</div><div class="line"># mac上安装</div><div class="line">pip install matplotlib</div></pre></td></tr></table></figure><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="快速入门小例子1之画单个图"><a href="#快速入门小例子1之画单个图" class="headerlink" title="快速入门小例子1之画单个图"></a>快速入门小例子1之画单个图</h2><p>我们只要有x轴的数和y轴的数,那么就可以在坐标轴上画出图来了.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">import numpy as np</div><div class="line">import matplotlib as mpl</div><div class="line">import matplotlib.pyplot as plt</div><div class="line"></div><div class="line"># 通过rcParams设置全局横纵轴字体大小</div><div class="line">mpl.rcParams[&apos;xtick.labelsize&apos;]=24</div><div class="line">mpl.rcParams[&apos;ytick.labelsize&apos;]=24</div><div class="line"></div><div class="line"># x轴的点</div><div class="line">x1 = np.arange(11)</div><div class="line"># y轴的点</div><div class="line">y1 = [</div><div class="line">    1.0847275042134147E-4,</div><div class="line">    2.0106877828356476E-4,</div><div class="line">    1.1836360644802181E-4,</div><div class="line">    0.043453404423487926,</div><div class="line">    0.03113001646083574,</div><div class="line">    0.06,</div><div class="line">    0.012709253496067191,</div><div class="line">    0.06,</div><div class="line">    3.284899860591644E-4,</div><div class="line">    0.015235253124714847,</div><div class="line">    0.0034946847451197242,</div><div class="line">]</div><div class="line"></div><div class="line"># 创建一个图,名字为ctr</div><div class="line">plt.figure(&quot;ctr&quot;)</div><div class="line"># 在图上绘制</div><div class="line">plt.plot(x1,y1)</div><div class="line"></div><div class="line"># 将当前figure的图像保存到文件result.png</div><div class="line">plt.savefig(&apos;result.pn</div><div class="line">g&apos;)</div><div class="line"># 一定要加上这句才能让画好的图显示在屏幕上</div><div class="line">plt.show()</div></pre></td></tr></table></figure></p><p>如图所示:<br><img src="/images/python/ctr1.png" alt="ctr1"></p><p>看上面就没有几行代码,但是就画出了一个图.所以用Matplotlib可以非常方便的绘制我们想要的图形.这里这是用最简单的例子说明一下.</p><h2 id="快速入门小例子2之把两组坐标画在一个图上进行比较"><a href="#快速入门小例子2之把两组坐标画在一个图上进行比较" class="headerlink" title="快速入门小例子2之把两组坐标画在一个图上进行比较"></a>快速入门小例子2之把两组坐标画在一个图上进行比较</h2><p>这里我们有两组数据,希望能够方便的比较这两组数据的差异,那么我们就可以把趋势都画在一个图上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">import numpy as np</div><div class="line">import matplotlib as mpl</div><div class="line">import matplotlib.pyplot as plt</div><div class="line"></div><div class="line"># 通过rcParams设置全局横纵轴字体大小</div><div class="line">mpl.rcParams[&apos;xtick.labelsize&apos;]=24</div><div class="line">mpl.rcParams[&apos;ytick.labelsize&apos;]=24</div><div class="line"></div><div class="line"># x轴的点</div><div class="line">x1 = np.arange(11)</div><div class="line"># y轴的点</div><div class="line">y1 = [</div><div class="line">    1.0847275042134147E-4,</div><div class="line">    2.0106877828356476E-4,</div><div class="line">    1.1836360644802181E-4,</div><div class="line">    0.043453404423487926,</div><div class="line">    0.03113001646083574,</div><div class="line">    0.06,</div><div class="line">    0.012709253496067191,</div><div class="line">    0.06,</div><div class="line">    3.284899860591644E-4,</div><div class="line">    0.015235253124714847,</div><div class="line">    0.0034946847451197242,</div><div class="line">]</div><div class="line"></div><div class="line"># 创建一个图,名字为ctr</div><div class="line">#plt.figure(&quot;ctr&quot;)</div><div class="line"># 在图上绘制</div><div class="line">#plt.plot(x1,y1)</div><div class="line"></div><div class="line"></div><div class="line">x2 = np.arange(11)</div><div class="line"></div><div class="line">y2 = [</div><div class="line">    3.529088519807792E-5,</div><div class="line">    1.1895968858318187E-4,</div><div class="line">    0.0013049292594645469,</div><div class="line">    0.046417845349992326,</div><div class="line">    0.03282177644291713,</div><div class="line">    0.06,</div><div class="line">    0.013313023920004725,</div><div class="line">    0.06,</div><div class="line">    3.554547063283854E-4,</div><div class="line">    0.014309633417956262,</div><div class="line">    0.0034946847451197242,</div><div class="line">]</div><div class="line"></div><div class="line"></div><div class="line">#plt.figure(&quot;ctrEstimate&quot;)</div><div class="line">#plt.plot(x2,y2,&apos;k&apos;)</div><div class="line"></div><div class="line"></div><div class="line"># 两个图画一起</div><div class="line">plt.figure(&apos;ctr &amp; ctrEstimate&apos;)</div><div class="line">plt.plot(x1, y1)</div><div class="line"></div><div class="line"># scatter可以方便出散点图</div><div class="line"># plt.scatter(x1,y11,c=&apos;red&apos;,marker=&apos;v&apos;)</div><div class="line"></div><div class="line"># plt.scatter(x2,y22,marker=&apos;^&apos;)</div><div class="line"></div><div class="line"># &apos;r&apos;表示用红色线</div><div class="line">plt.plot(x2, y2, &apos;r&apos;)</div><div class="line"></div><div class="line">plt.show()</div></pre></td></tr></table></figure></p><p>如图所示:<br><img src="/images/python/ctr2.png" alt="ctr2"></p><h2 id="入门小例子3之多布局"><a href="#入门小例子3之多布局" class="headerlink" title="入门小例子3之多布局"></a>入门小例子3之多布局</h2><p>在一张图上构建多个布局画多张图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">import matplotlib as mpl</div><div class="line">import matplotlib.pyplot as plt</div><div class="line"></div><div class="line"># 通过rcParams设置全局横纵轴字体大小</div><div class="line">mpl.rcParams[&apos;xtick.labelsize&apos;]=24</div><div class="line">mpl.rcParams[&apos;ytick.labelsize&apos;]=24</div><div class="line"></div><div class="line">x=range(10)</div><div class="line"></div><div class="line">y=[5,4,3,2,1,6,7,8,9,0]</div><div class="line"></div><div class="line">fig=plt.figure(&quot;one figure many subplot&quot;)</div><div class="line">ax=fig.add_subplot(131)</div><div class="line">ax.set_title(&apos;Histogram&apos;)</div><div class="line">ax.bar(x,y)</div><div class="line"></div><div class="line">ax=fig.add_subplot(132)</div><div class="line">ax.set_title(&apos;line chart&apos;)</div><div class="line">ax.plot(x,y)</div><div class="line"></div><div class="line">ax=fig.add_subplot(133)</div><div class="line">ax.set_title(u&apos;Scatter plot&apos;)</div><div class="line">ax.scatter(x,y)</div><div class="line"></div><div class="line">plt.show()</div></pre></td></tr></table></figure></p><p>如图所示<br><img src="/images/python/figure.png" alt="figure"></p><h1 id="matplotlib画图api解释"><a href="#matplotlib画图api解释" class="headerlink" title="matplotlib画图api解释"></a>matplotlib画图api解释</h1><p>单独的讲解api很无聊.直接写代码画图,代码里都有详细的说明</p><h2 id="画2维的柱图和饼图"><a href="#画2维的柱图和饼图" class="headerlink" title="画2维的柱图和饼图"></a>画2维的柱图和饼图</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import numpy as np</div><div class="line"></div><div class="line">import matplotlib as mpl</div><div class="line">import matplotlib.pyplot as plt</div><div class="line"></div><div class="line">mpl.rcParams[&apos;axes.titlesize&apos;] = 20</div><div class="line">mpl.rcParams[&apos;xtick.labelsize&apos;] = 16</div><div class="line">mpl.rcParams[&apos;ytick.labelsize&apos;] = 16</div><div class="line">mpl.rcParams[&apos;axes.labelsize&apos;] = 16</div><div class="line">mpl.rcParams[&apos;xtick.major.size&apos;] = 0</div><div class="line">mpl.rcParams[&apos;ytick.major.size&apos;] = 0</div><div class="line"></div><div class="line"># 包含了狗,猫和猎豹的最高奔跑速度,还有对应的可视化颜色</div><div class="line">speed_map = &#123;</div><div class="line">    &apos;dog&apos;: (48, &apos;#7199cf&apos;),</div><div class="line">    &apos;cat&apos;: (45, &apos;#4fc4aa&apos;),</div><div class="line">    &apos;cheetah&apos;: (120, &apos;#e1a7a2&apos;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"># 整体图的标图</div><div class="line">fig=plt.figure(&apos;Bar chart &amp; Pie chart&apos;)</div><div class="line"></div><div class="line"># 在整张图上加入一个子图,121的意思是在一个1行2列的子图中的第一张</div><div class="line">ax=fig.add_subplot(121)</div><div class="line">ax.set_title(&quot;Running speed - bar chart&quot;)</div><div class="line"></div><div class="line"># 生成x轴每个元素的位置 0 1 2</div><div class="line">xticks=np.arange(3)</div><div class="line"></div><div class="line"># 定义柱状图每个柱的宽度</div><div class="line">bar_width=0.5</div><div class="line"></div><div class="line"># 动物名称</div><div class="line">animals=speed_map.keys()</div><div class="line"></div><div class="line"># 奔跑速度</div><div class="line">speeds=[x[0] for x in speed_map.values()]</div><div class="line"></div><div class="line"># 对应颜色</div><div class="line">colors=[x[1] for x in speed_map.values()]</div><div class="line"></div><div class="line"># 画柱状图,横轴是动物标签的位置,纵轴是速度,定义柱的宽度,同时设置柱的边缘为透明</div><div class="line">bars=ax.bar(xticks,speeds,width=bar_width,edgecolor=&apos;none&apos;)</div><div class="line"></div><div class="line"># 设置y轴的标图</div><div class="line">ax.set_ylabel(&apos;Speed(km/h)&apos;)</div><div class="line"></div><div class="line"># x轴每个标签的具体位置,设置为每个柱的中央</div><div class="line">ax.set_xticks(xticks+bar_width/2)</div><div class="line"></div><div class="line"># 设置每个标签的名字</div><div class="line">ax.set_xticklabels(animals)</div><div class="line"></div><div class="line"># 设置x轴的范围</div><div class="line">ax.set_xlim([bar_width/2-0.5,3-bar_width/2])</div><div class="line"></div><div class="line"># 设置y轴的范围</div><div class="line">ax.set_ylim([0,125])</div><div class="line"></div><div class="line"># 给每个bar分配指定的颜色</div><div class="line">for bar,color in zip(bars,colors):</div><div class="line">    bar.set_color(color)</div><div class="line"></div><div class="line"></div><div class="line"># 在122位置加入新的图</div><div class="line">ax=fig.add_subplot(122)</div><div class="line">ax.set_title(&apos;Running speed - pie chart&apos;)</div><div class="line">labels=[&apos;&#123;&#125;\n&#123;&#125; km/h&apos;.format(animal,speed) for animal,speed in zip(animals,speeds)]</div><div class="line"></div><div class="line"># 画饼状图,并指定标签和对应颜色</div><div class="line">ax.pie(speeds,labels=labels,colors=colors)</div><div class="line"># ax.plot(speeds)</div><div class="line"></div><div class="line"></div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="/images/python/subplot.png" alt="subplot"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Matplotlib是Python中最常用的可视化工具之一，可以非常方便地创建海量类型地2D图表和一些基本的3D图表。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://dmlcoding.com/categories/python/"/>
    
    
      <category term="python" scheme="http://dmlcoding.com/tags/python/"/>
    
      <category term="Matplotlib" scheme="http://dmlcoding.com/tags/Matplotlib/"/>
    
  </entry>
  
  <entry>
    <title>Hbase笔记</title>
    <link href="http://dmlcoding.com/2017/HbaseNotes/"/>
    <id>http://dmlcoding.com/2017/HbaseNotes/</id>
    <published>2017-07-24T02:00:00.000Z</published>
    <updated>2017-07-25T06:07:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>在开发hbase过程中,遇到的一些问题.还有些许知识点的总结.<br><a id="more"></a></p><h1 id="hbase的内存分配"><a href="#hbase的内存分配" class="headerlink" title="hbase的内存分配"></a>hbase的内存分配</h1><blockquote><p>HBase的默认堆分配策略，40%给blockcache，40%给memstore<br>在HBase中，有两个在内存中的结构消费了绝大多数的heap空间。BlockCache缓存读操作的HFile block，Memstore缓存近期的写操作。</p></blockquote><ul><li>hfile.block.cache.size(读多的场景下,适当增大这个参数的值)</li><li>hbase.regionserver.global.memstore.upperLimit(写多的场景下,适当增大这个参数的值)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发hbase过程中,遇到的一些问题.还有些许知识点的总结.&lt;br&gt;
    
    </summary>
    
      <category term="hbase" scheme="http://dmlcoding.com/categories/hbase/"/>
    
    
      <category term="hbase" scheme="http://dmlcoding.com/tags/hbase/"/>
    
      <category term="bigdata" scheme="http://dmlcoding.com/tags/bigdata/"/>
    
  </entry>
  
  <entry>
    <title>年中总结</title>
    <link href="http://dmlcoding.com/2017/WhatIWriteIsShit/"/>
    <id>http://dmlcoding.com/2017/WhatIWriteIsShit/</id>
    <published>2017-07-16T02:20:00.000Z</published>
    <updated>2017-07-18T02:01:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/beautifulPic/1.jpg" alt="风景"><br>写了这么多句,没有写出一句有意思的话;<br>写了这么多篇,没有写出一篇有深意的文章;<br>不是流水账,仍似流水账;</p><a id="more"></a><h1 id="我干了些啥"><a href="#我干了些啥" class="headerlink" title="我干了些啥"></a>我干了些啥</h1><blockquote><p>2017已经过去了一半</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/beautifulPic/1.jpg&quot; alt=&quot;风景&quot;&gt;&lt;br&gt;写了这么多句,没有写出一句有意思的话;&lt;br&gt;写了这么多篇,没有写出一篇有深意的文章;&lt;br&gt;不是流水账,仍似流水账;&lt;/p&gt;
    
    </summary>
    
      <category term="think" scheme="http://dmlcoding.com/categories/think/"/>
    
    
      <category term="think" scheme="http://dmlcoding.com/tags/think/"/>
    
  </entry>
  
  <entry>
    <title>逻辑回归笔记</title>
    <link href="http://dmlcoding.com/2017/LogicalRegression/"/>
    <id>http://dmlcoding.com/2017/LogicalRegression/</id>
    <published>2017-07-12T09:24:00.000Z</published>
    <updated>2017-07-13T10:30:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>不知道什么是逻辑回归,但是也许看完接下来的文章,你会有个大概的印象吧<br><a id="more"></a></p><h1 id="简单介绍Logistic回归"><a href="#简单介绍Logistic回归" class="headerlink" title="简单介绍Logistic回归"></a>简单介绍Logistic回归</h1><h2 id="Logistic回归用到的知识点"><a href="#Logistic回归用到的知识点" class="headerlink" title="Logistic回归用到的知识点"></a>Logistic回归用到的知识点</h2><ul><li>Sigmoid函数和Logistic回归分类器</li><li>最优化理论初步</li><li>梯度下降最优化算法</li><li>数据中的缺失项处理</li></ul><h2 id="Logistic回归的一般过程"><a href="#Logistic回归的一般过程" class="headerlink" title="Logistic回归的一般过程"></a>Logistic回归的一般过程</h2><ul><li>1.收集数据:采用任意方法收集数据</li><li>2.准备数据:由于需要进行距离计算,因此要求数据类型为数值型.另外,结构化数据格式则最佳.</li><li>3.分析数据:采用任意方法对数据进行分析.</li><li>4.训练算法:大部分时间将用于训练,训练的目的是为了找到最佳的分类回归系数.</li><li>5.使用算法:首先,我们需要一些输入数据,并将其转换成对应的结构化数值;接着,基于训练好的回归系数就可以对这些数值进行简单的回归计算,判定他们属于哪个类别;在这之后,我们就可以在输出的类别上做一些其他分析工作.</li></ul><h1 id="基于Logistic回归和Sigmoid函数的分类"><a href="#基于Logistic回归和Sigmoid函数的分类" class="headerlink" title="基于Logistic回归和Sigmoid函数的分类"></a>基于Logistic回归和Sigmoid函数的分类</h1><h2 id="Logistic回归"><a href="#Logistic回归" class="headerlink" title="Logistic回归"></a>Logistic回归</h2><ul><li>优点<ul><li>计算代价不高</li><li>易于理解和实现</li></ul></li><li>缺点<ul><li>容易欠拟合</li><li>分类精度可能不高</li></ul></li><li>适用类型<ul><li>数值型(数值型目标变量则可以从无限的数值集合中取值，如0.100，42.001等 (数值型目标变量主要用于回归分析))</li><li>标称型数据(标称型目标变量的结果只在有限目标集中取值，如真与假(标称型目标变量主要用于分类))</li></ul></li></ul><p>基本公式:<br>Sigmoid函数具体的计算公式</p><math xmlns="http://www.w3.org/1998/Math/MathML">  <mstyle displaystyle="true">    <mi> &#x03C3;<!--greek small letter sigma--> </mi>    <mfenced>      <mrow>        <mi> z </mi>      </mrow>    </mfenced>    <mo> = </mo>    <mfrac>      <mrow>        <mn> 1 </mn>      </mrow>      <mrow>        <mn> 1 </mn>        <mo> + </mo>        <msup>          <mrow>            <mi> e </mi>          </mrow>          <mrow>            <mo> - </mo>            <mi> z </mi>          </mrow>        </msup>      </mrow>    </mfrac>  </mstyle></math>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知道什么是逻辑回归,但是也许看完接下来的文章,你会有个大概的印象吧&lt;br&gt;
    
    </summary>
    
      <category term="ml" scheme="http://dmlcoding.com/categories/ml/"/>
    
    
      <category term="ml" scheme="http://dmlcoding.com/tags/ml/"/>
    
  </entry>
  
  <entry>
    <title>druid遇到的坑</title>
    <link href="http://dmlcoding.com/2017/DruidQuickStart/"/>
    <id>http://dmlcoding.com/2017/DruidQuickStart/</id>
    <published>2017-07-09T10:24:00.000Z</published>
    <updated>2017-07-10T10:27:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习druid过程中遇到的一些坑,记录一下.方便自己方便大家.<br><a id="more"></a></p><h1 id="提交任务失败"><a href="#提交任务失败" class="headerlink" title="提交任务失败"></a>提交任务失败</h1><ul><li><p>错误日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1) Not enough direct memory.  Please adjust -XX:MaxDirectMemorySize, druid.processing.buffer.sizeBytes,</div><div class="line"> druid.processing.numThreads, or druid.processing.numMergeBuffers: maxDirectMemory[8,589,934,592],</div><div class="line"> memoryNeeded[13,958,643,712] = druid.processing.buffer.sizeBytes[1,073,741,824] *</div><div class="line">  (druid.processing.numMergeBuffers[2] + druid.processing.numThreads[10] + 1)</div></pre></td></tr></table></figure></li><li><p>解决办法<br>修改启动参数中的配置conf/druid/middlemanager/runtime.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-XX:MaxDirectMemorySize=25g</div><div class="line">druid.processing.numThreads=35</div><div class="line">只需要将处理线程数改小，或者调大启动参数 -XX:MaxDirectMemorySize 即可</div></pre></td></tr></table></figure></li></ul><h1 id="coordinator协调节点-数据源报红"><a href="#coordinator协调节点-数据源报红" class="headerlink" title="coordinator协调节点,数据源报红"></a>coordinator协调节点,数据源报红</h1><ul><li>问题描述<br><img src="/images/pics/druiderror1.png" alt="数据源报红"></li><li>解决办法<br><img src="/images/pics/druidR1.png" alt="数据源报红"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习druid过程中遇到的一些坑,记录一下.方便自己方便大家.&lt;br&gt;
    
    </summary>
    
      <category term="druid" scheme="http://dmlcoding.com/categories/druid/"/>
    
    
      <category term="druid" scheme="http://dmlcoding.com/tags/druid/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu16.04使用Docker部署Gitlab</title>
    <link href="http://dmlcoding.com/2017/DockerInstallGitlab/"/>
    <id>http://dmlcoding.com/2017/DockerInstallGitlab/</id>
    <published>2017-07-05T10:24:00.000Z</published>
    <updated>2017-07-06T09:48:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>我个人非常不喜欢用SVN同步代码,正好想重温一下docker的一些命令,那就用docker方便的搭建一下gitlab.</p><h1 id="ubuntu安装docker"><a href="#ubuntu安装docker" class="headerlink" title="ubuntu安装docker"></a>ubuntu安装docker</h1><a id="more"></a><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><blockquote><p>Docker 要求 Ubuntu 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的Ubuntu版本是否支持 Docker 。<br>打开控制台使用 uname -r命令来查看你当前的内核版本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ uname -r</div><div class="line"> 3.11.0-15-generic</div></pre></td></tr></table></figure></p></blockquote><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get update $ sudo apt-get install wget  //安装wget</div><div class="line">wget -qO- https://get.docker.com/ | sh     //获取最新版本的 Docker 安装包，输入完成之后，就会下载脚本并且安装Docker及依赖包。</div><div class="line">docker info //验证安装结果</div></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h2 id="Cannot-connect-to-the-Docker-daemon-Is-the-docker-daemon-running-on-this-host"><a href="#Cannot-connect-to-the-Docker-daemon-Is-the-docker-daemon-running-on-this-host" class="headerlink" title="Cannot connect to the Docker daemon. Is the docker daemon running on this host?"></a>Cannot connect to the Docker daemon. Is the docker daemon running on this host?</h2><ul><li>解决:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo su -                       //切换到root</div><div class="line">service docker start      //启动docker service</div><div class="line">docker images              //显示所有images</div><div class="line">docker run hello-world  //重新运行</div></pre></td></tr></table></figure></li></ul><p>恩，是权限问题，当前用户没权限，root用户可以运行</p><h1 id="下载需要的镜像"><a href="#下载需要的镜像" class="headerlink" title="下载需要的镜像"></a>下载需要的镜像</h1><p>以下脚本会下载gitlab,mysql,redis镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker pull sameersbn/gitlab:latest</div><div class="line">docker pull sameersbn/mysql:latest</div><div class="line">docker pull sameersbn/redis:latest</div></pre></td></tr></table></figure></p><h1 id="启动需要的镜像"><a href="#启动需要的镜像" class="headerlink" title="启动需要的镜像"></a>启动需要的镜像</h1><h2 id="启动redis"><a href="#启动redis" class="headerlink" title="启动redis"></a>启动redis</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker run \</div><div class="line">  --name=gitlab_redis \</div><div class="line">  -tid \</div><div class="line">  sameersbn/redis:latest</div></pre></td></tr></table></figure><h2 id="启动mysql"><a href="#启动mysql" class="headerlink" title="启动mysql"></a>启动mysql</h2><p>注意这里写你的用户名和密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">mkdir -p /opt/gitlab/mysql</div><div class="line">docker run \</div><div class="line">  --name=gitlab_mysql \</div><div class="line">  -tid \</div><div class="line">  -e &apos;DB_NAME=gitlabhq_production&apos; \</div><div class="line">  -e &apos;DB_USER=gitlab&apos; \</div><div class="line">  -e &apos;DB_PASS=password&apos; \</div><div class="line">  -v /opt/gitlab/mysql:/var/lib/mysql \</div><div class="line">  sameersbn/mysql:latest</div></pre></td></tr></table></figure></p><h2 id="启动gitlab"><a href="#启动gitlab" class="headerlink" title="启动gitlab"></a>启动gitlab</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">docker run \</div><div class="line">  --name=&apos;gitlab&apos; \</div><div class="line">  -itd \</div><div class="line">  --link gitlab_mysql:mysql \</div><div class="line">  --link gitlab_redis:redisio \</div><div class="line">  -e &apos;GITLAB_PORT=80&apos; \</div><div class="line">  -e &apos;GITLAB_SSH_PORT=22&apos; \</div><div class="line">  --env &apos;GITLAB_SECRETS_DB_KEY_BASE=long-and-random-alpha-numeric-string&apos; \</div><div class="line">  --env &apos;GITLAB_SECRETS_SECRET_KEY_BASE=long-and-random-alpha-numeric-string&apos; \</div><div class="line">  --env &apos;GITLAB_SECRETS_OTP_KEY_BASE=long-and-random-alpha-numeric-string&apos; \</div><div class="line">  -p 10022:22 -p 10080:80 \</div><div class="line">  -v /var/run/docker.sock:/run/docker.sock \</div><div class="line">  -v $(which docker):/bin/docker \</div><div class="line">  -v /opt/gitlab/data:/home/git/data \</div><div class="line">  -v /opt/gitlab/log:/var/log/gitlab \</div><div class="line">  sameersbn/gitlab:latest</div></pre></td></tr></table></figure><p>这一步骤会耗时几分钟，因为这一步会做一些初始化操作,我们可以通过docker logs gitlab来查看安装过程。<br>我们指定了10022作为ssh的访问端口，10080作为http的访问端口，</p><p>执行完后，稍微过1-2分钟后，打开以下地址应该就可以访问gitlab了<br><a href="http://localhost:10080" target="_blank" rel="external">http://localhost:10080</a><br>如果是在服务器上搭建，请替换localhost为服务器地址</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h2><p>当出了问题,可以用一些命令查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 列出正在运行的容器</div><div class="line">root@bigdata:~# docker ps</div><div class="line">CONTAINER ID        IMAGE                     COMMAND                  CREATED             STATUS              PORTS                                                   NAMES</div><div class="line">aa93b0654f4b        sameersbn/gitlab:latest   &quot;/sbin/entrypoint....&quot;   43 minutes ago      Up 13 minutes       443/tcp, 0.0.0.0:10022-&gt;22/tcp, 0.0.0.0:10080-&gt;80/tcp   gitlab</div><div class="line">881c31d50c53        sameersbn/mysql:latest    &quot;/sbin/entrypoint....&quot;   About an hour ago   Up 14 minutes       3306/tcp                                                gitlab_mysql</div><div class="line">e5573736680f        sameersbn/redis:latest    &quot;/sbin/entrypoint.sh&quot;    About an hour ago   Up 14 minutes       6379/tcp                                                gitlab_redis</div></pre></td></tr></table></figure><ul><li>列出所有容器的状态<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">root@bigdata:~# docker ps -a</div><div class="line">CONTAINER ID        IMAGE                     COMMAND                  CREATED             STATUS              PORTS                                                   NAMES</div><div class="line">aa93b0654f4b        sameersbn/gitlab:latest   &quot;/sbin/entrypoint....&quot;   44 minutes ago      Up 14 minutes       443/tcp, 0.0.0.0:10022-&gt;22/tcp, 0.0.0.0:10080-&gt;80/tcp   gitlab</div><div class="line">881c31d50c53        sameersbn/mysql:latest    &quot;/sbin/entrypoint....&quot;   About an hour ago   Up 14 minutes       3306/tcp                                                gitlab_mysql</div><div class="line">e5573736680f        sameersbn/redis:latest    &quot;/sbin/entrypoint.sh&quot;    About an hour ago   Up 15 minutes       6379/tcp                                                gitlab_redis</div></pre></td></tr></table></figure></li></ul><p>后面可以是容易id,也可以是容器名称</p><ul><li>docker start CONTAINER ID #启动容器</li><li>docker stop CONTAINER ID #停止容器</li><li>docker rm -f CONTAINER ID #删除容器</li><li>docker logs CONTAINERID  #查看容器的运行时日志</li></ul><h1 id="进入docker中的服务器"><a href="#进入docker中的服务器" class="headerlink" title="进入docker中的服务器"></a>进入docker中的服务器</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker exec -it 容器名字 bash</div></pre></td></tr></table></figure><p>举例:<br>上面部署gitlab,我们还启动了一个mysql容器,我们可以进入这个mysql容器里面看看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">root@bigdata:~# docker exec -it gitlab_mysql bash</div><div class="line">root@881c31d50c53:/# mysql</div><div class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</div><div class="line">Your MySQL connection id is 16</div><div class="line">Server version: 5.5.54-0ubuntu0.14.04.1 (Ubuntu)</div><div class="line"></div><div class="line">Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.</div><div class="line"></div><div class="line">Oracle is a registered trademark of Oracle Corporation and/or its</div><div class="line">affiliates. Other names may be trademarks of their respective</div><div class="line">owners.</div><div class="line"></div><div class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.</div><div class="line"></div><div class="line">mysql&gt;</div></pre></td></tr></table></figure></p><p>这样就进入了mysql容器中了.</p><h1 id="加入开机启动"><a href="#加入开机启动" class="headerlink" title="加入开机启动"></a>加入开机启动</h1><p>加入/etc/rc.local</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">echo &apos;docker start gitlab_redis&apos; &gt;&gt; /etc/rc.local</div><div class="line">echo &apos;docker start gitlab_mysql&apos; &gt;&gt; /etc/rc.local</div><div class="line">echo &apos;docker start gitlab&apos; &gt;&gt; /etc/rc.local</div></pre></td></tr></table></figure><h1 id="备份和恢复gitlab"><a href="#备份和恢复gitlab" class="headerlink" title="备份和恢复gitlab"></a>备份和恢复gitlab</h1><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker stop gitlab &amp;&amp; docker rm gitlab</div><div class="line">docker run --name=gitlab -it --rm [OPTIONS] \</div><div class="line">sameersbn/gitlab:latest app:rake gitlab:backup:create</div></pre></td></tr></table></figure><h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker stop gitlab &amp;&amp; docker rm gitlab</div><div class="line">docker run --name=gitlab -it --rm [OPTIONS] \</div><div class="line">sameersbn/gitlab:latest app:rake gitlab:backup:restore</div></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>当进入了gitlab的web页面后,新建了一个项目.可以用下面的链接去把工程clone下来.<br>ip换成你的ip地址.因为上面做了端口映射容器的80端口映射到外面是10080端口.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone http://10.211.55.7:10080/shiwei/learndocker.git</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我个人非常不喜欢用SVN同步代码,正好想重温一下docker的一些命令,那就用docker方便的搭建一下gitlab.&lt;/p&gt;
&lt;h1 id=&quot;ubuntu安装docker&quot;&gt;&lt;a href=&quot;#ubuntu安装docker&quot; class=&quot;headerlink&quot; title=&quot;ubuntu安装docker&quot;&gt;&lt;/a&gt;ubuntu安装docker&lt;/h1&gt;
    
    </summary>
    
      <category term="docker" scheme="http://dmlcoding.com/categories/docker/"/>
    
    
      <category term="ubuntu" scheme="http://dmlcoding.com/tags/ubuntu/"/>
    
      <category term="docker" scheme="http://dmlcoding.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>项目中配置文件的读取</title>
    <link href="http://dmlcoding.com/2017/ReadConfigFile/"/>
    <id>http://dmlcoding.com/2017/ReadConfigFile/</id>
    <published>2017-06-25T03:41:00.000Z</published>
    <updated>2017-07-07T06:08:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>在工作中,我们一般都不会把变化的地方写死.比如开发环境和测试环境的服务器地址,等等之类的信息.这些我们都会写入到配置文件中,方便修改.<br><a id="more"></a></p><h1 id="com-typesafe-config加载任意位置的配置文件"><a href="#com-typesafe-config加载任意位置的配置文件" class="headerlink" title="com.typesafe.config加载任意位置的配置文件"></a>com.typesafe.config加载任意位置的配置文件</h1><blockquote><p>typesafe下的config包可以用来读取配置文件，支持多种形式。</p></blockquote><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><blockquote><p>Typesafe的Config库，纯Java写成、零外部依赖、代码精简、功能灵活、API友好。支持Java properties、JSON、JSON超集格式HOCON以及环境变量。它也是Akka的配置管理库.</p></blockquote><p>如果没引上,使用如下依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;!-- https://mvnrepository.com/artifact/com.typesafe/config --&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;com.typesafe&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;config&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.3.1&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure><ul><li>纯java实现，无任何依赖   </li><li>可以合并各种格式的配置文件  </li><li>可以通过文件、urls、classpath加载配置  </li><li>支持多层嵌套的配置方式  </li><li>可以转换长短，大小等单位  </li><li>类型转换  </li></ul><h2 id="加载配置文件的两种方式"><a href="#加载配置文件的两种方式" class="headerlink" title="加载配置文件的两种方式"></a>加载配置文件的两种方式</h2><p>目录结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> hushiwei@localhost  ~/IdeaProjects/testProject/src/main  tree</div><div class="line">.</div><div class="line">├── java</div><div class="line">│   └── com</div><div class="line">│       └── husw</div><div class="line">├── resources</div><div class="line">│   ├── conf</div><div class="line">│   │   └── application.conf</div><div class="line">│   ├── testlog.txt</div><div class="line">│   └── log4j.properties</div><div class="line">└── scala</div></pre></td></tr></table></figure></p><p>配置文件示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">kafka &#123;</div><div class="line">  topics = &quot;test_imp&quot; #注释</div><div class="line">  brokers = &quot;192.168.1.1:9092,192.168.2.1:9092&quot;</div><div class="line">  groupid=&quot;test_group1&quot;</div><div class="line">  offset_reset=&quot;smallest&quot; #smallest and largest</div><div class="line">&#125;</div><div class="line">spark &#123;</div><div class="line">  app_name = &quot;dsp_count&quot;</div><div class="line">  mode = &quot;local[2]&quot; #&quot;yarn-client&quot;</div><div class="line">  queue = &quot;normal&quot;</div><div class="line">  duration = 2</div><div class="line">  numFilesPerBatch = 1</div><div class="line">  stagingdir = &quot;/tmp/spark/checkpoint&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="加载resources目录下的配置文件"><a href="#加载resources目录下的配置文件" class="headerlink" title="加载resources目录下的配置文件"></a>加载resources目录下的配置文件</h3><p>默认读取resources目录下的文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val config = ConfigFactory.load(&quot;conf/application.conf&quot;)</div></pre></td></tr></table></figure></p><h3 id="加载任意指定位置的配置文件"><a href="#加载任意指定位置的配置文件" class="headerlink" title="加载任意指定位置的配置文件"></a>加载任意指定位置的配置文件</h3><p>路径可以写任意的绝对路径,或者相对路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val config = ConfigFactory.parseFile(new File(&quot;src/main/resources/conf/application.conf&quot;))</div></pre></td></tr></table></figure></p><h3 id="获取配置文件中的键值"><a href="#获取配置文件中的键值" class="headerlink" title="获取配置文件中的键值"></a>获取配置文件中的键值</h3><p>读取配置文件后返回了config对象.<br>直接调用config对象相应的api即可获取配置数据了<br><a href="http://typesafehub.github.io/config/latest/api/com/typesafe/config/ConfigFactory.html" target="_blank" rel="external">Api文档</a><br>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val topics = config.getString(&quot;kafka.topics&quot;).split(&quot;,&quot;).toSet</div><div class="line">println(topics)</div></pre></td></tr></table></figure></p><p>若要知道更详细的api说明,点击上面的链接即可.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在工作中,我们一般都不会把变化的地方写死.比如开发环境和测试环境的服务器地址,等等之类的信息.这些我们都会写入到配置文件中,方便修改.&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://dmlcoding.com/categories/java/"/>
    
    
      <category term="java" scheme="http://dmlcoding.com/tags/java/"/>
    
      <category term="scala" scheme="http://dmlcoding.com/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title>python 高级特性之切片</title>
    <link href="http://dmlcoding.com/2017/PythonSplitFunc/"/>
    <id>http://dmlcoding.com/2017/PythonSplitFunc/</id>
    <published>2017-06-21T07:24:00.000Z</published>
    <updated>2017-06-22T07:36:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>python很方便实用,如果你不会切片.那么你真的错过了什么叫方便和实用.<br><a id="more"></a></p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul><li>python中的序列可以使用切片特性</li><li>序列类型后面跟上一对方括号.</li><li>方括号有一对<strong>可选</strong>的数字,并用冒号分隔.</li><li>冒号是必须的</li></ul><p>切片操作符中的第一个数（冒号之前）表示切片开始的位置，第二个数（冒号之后）表示切片到哪里结束，<br>第三个数（冒号之后）表示切片间隔数(也就是步长)。如果不指定第一个数，Python就从序列首开始。如果没有指定第二个数，则python会停止在序列尾。<br>注意:左包右闭<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">str=&apos;dmlcoding.com&apos;</div><div class="line">str[]</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python很方便实用,如果你不会切片.那么你真的错过了什么叫方便和实用.&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="http://dmlcoding.com/categories/python/"/>
    
    
      <category term="python" scheme="http://dmlcoding.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Git 常用命令以及笔记</title>
    <link href="http://dmlcoding.com/2017/GitSkills/"/>
    <id>http://dmlcoding.com/2017/GitSkills/</id>
    <published>2017-06-20T06:00:00.000Z</published>
    <updated>2017-07-13T07:08:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>平时一直是用Intellij进行开发,git命令也不会用命令行去输入.导致有些命令都不太熟悉了,每次用到的时候都是google.<br>今天把平时用到的命令做个笔记记录一下.</p><a id="more"></a><h1 id="git分布式仓库工作流程"><a href="#git分布式仓库工作流程" class="headerlink" title="git分布式仓库工作流程"></a>git分布式仓库工作流程</h1><p>这里有个图,非常形象的展示了本地仓库和远程仓库以及常用的一些命令的作用范围.<br>一图胜千言,图片摘自<a href="http://krishnaiitd.github.io/gitcommands/git-workflow/" target="_blank" rel="external">http://krishnaiitd.github.io/gitcommands/git-workflow/</a><br><img src="/images/pics/GitWorkflow.png" alt="git工作流"><br><img src="../images/pics/GitWorkflow.png" alt="git工作流"></p><h1 id="设置-commit-的用户和邮箱"><a href="#设置-commit-的用户和邮箱" class="headerlink" title="设置 commit 的用户和邮箱"></a>设置 commit 的用户和邮箱</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git config user.name &quot;xx&quot;               #设置 commit 的用户</div><div class="line">git config user.email &quot;xx@xx.com&quot;       #设置 commit 的邮箱</div><div class="line">git commit --amend --author &quot;xxx &lt;xxx@gmail.com&gt;&quot;    #修改上次提交的用户信息</div><div class="line">git config format.pretty oneline        #显示历史记录时，每个提交的信息只显示一行</div></pre></td></tr></table></figure><h2 id="配置本地到github的免密"><a href="#配置本地到github的免密" class="headerlink" title="配置本地到github的免密"></a>配置本地到github的免密</h2><p>参考我之前写的 <a href="http://dmlcoding.com/2016/sshlogin/">http://dmlcoding.com/2016/sshlogin/</a></p><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><h2 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote add origin git@server-name:path/repo-name.git  #添加一个远程库</div></pre></td></tr></table></figure><h2 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h2><blockquote><p>origin是远程仓库的别名,约定俗成的叫做original.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git remote      #要查看远程库的信息</div><div class="line">git remote -v   #显示更详细的信息</div></pre></td></tr></table></figure><h2 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push origin master    #推送到远程master分支</div></pre></td></tr></table></figure><h2 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git clone git@server-name:path/repo-name.git   #克隆远程仓库到本地(能看到master分支)</div><div class="line">git checkout -b dev origin/dev  #创建远程origin的dev分支到本地，并命名为dev</div><div class="line">git checkout origin/dev --track #与上面效果一样</div><div class="line">git pull origin master          #从远程分支进行更新</div><div class="line">git fetch origin master         #获取远程分支上的数据</div></pre></td></tr></table></figure><h2 id="抓取GitHub上某个pull-request到本地"><a href="#抓取GitHub上某个pull-request到本地" class="headerlink" title="抓取GitHub上某个pull request到本地"></a>抓取GitHub上某个pull request到本地</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git fetch origin pull/ID/head:BRANCHNAME</div><div class="line">git checkout BRANCHNAME</div><div class="line">$ git branch --set-upstream branch-name origin/branch-name，可以建立起本地分支和远程分支的关联，之后可以直接git pull从远程抓取分支。</div><div class="line"></div><div class="line">另外，git pull = git fetch + merge to local</div></pre></td></tr></table></figure><h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ git push origin --delete bugfix</div><div class="line">To https://github.com/wuchong/jacman</div><div class="line"> - [deleted]         bugfix</div><div class="line"># 或者直接push一个空分支</div><div class="line">$ git push origin :bugfix</div><div class="line">To https://github.com/wuchong/jacman</div><div class="line"> - [deleted]         bugfix</div></pre></td></tr></table></figure><h2 id="更新远程分支信息"><a href="#更新远程分支信息" class="headerlink" title="更新远程分支信息"></a>更新远程分支信息</h2><p>项目往前推进的过程中，远程仓库上经常会增加一些分支、删除一些分支。 所以有时需要与远程同步下分支信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git fetch -p</div></pre></td></tr></table></figure></p><p>-p就是修剪的意思。它在fetch之后删除掉没有与远程分支对应的本地分支，并且同步一些远程新创建的分支和tag。</p><h1 id="历史管理"><a href="#历史管理" class="headerlink" title="历史管理"></a>历史管理</h1><h2 id="查看历史"><a href="#查看历史" class="headerlink" title="查看历史"></a>查看历史</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git log --pretty=oneline filename #一行显示</div><div class="line">git log -p -2      #显示最近2次提交内容的差异</div><div class="line">git show cb926e7   #查看某次修改</div></pre></td></tr></table></figure><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git reset --hard HEAD^    #回退到上一个版本</div><div class="line">git reset --hard cb926e7  #回退到具体某个版</div><div class="line">git reflog                #查看命令历史,常用于帮助找回丢失掉的commit</div></pre></td></tr></table></figure><p>用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，HEAD~100就是上100个版本。</p><h1 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git status              #查看工作区、暂存区的状态</div><div class="line">git checkout -- &lt;file&gt;  #丢弃工作区上某个文件的修改</div><div class="line">git reset HEAD &lt;file&gt;   #丢弃暂存区上某个文件的修改，重新放回工作区</div></pre></td></tr></table></figure><h2 id="查看差异"><a href="#查看差异" class="headerlink" title="查看差异"></a>查看差异</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git diff              #查看未暂存的文件更新</div><div class="line">git diff --cached     #查看已暂存文件的更新</div><div class="line">git diff HEAD -- readme.txt  #查看工作区和版本库里面最新版本的区别</div><div class="line">git diff &lt;source_branch&gt; &lt;target_branch&gt;  #在合并改动之前，预览两个分支的差异</div><div class="line">使用内建的图形化git：gitk，可以更方便清晰地查看差异。当然 Github 客户端也不错。</div></pre></td></tr></table></figure><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git rm &lt;file&gt;           #直接删除文件</div><div class="line">git rm --cached &lt;file&gt;  #删除文件暂存状态</div></pre></td></tr></table></figure><h2 id="储藏和恢复"><a href="#储藏和恢复" class="headerlink" title="储藏和恢复"></a>储藏和恢复</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git stash           #储藏当前工作</div><div class="line">git stash list      #查看储藏的工作现场</div><div class="line">git stash apply     #恢复工作现场，stash内容并不删除</div><div class="line">git stash pop       #恢复工作现场，并删除stash内容</div></pre></td></tr></table></figure><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git branch develop              #只创建分支</div><div class="line">git checkout -b master develop  #创建并切换到 develop 分支</div></pre></td></tr></table></figure><h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git checkout master         #切换到主分支</div><div class="line">git merge --no-ff develop   #把 develop 合并到 master 分支，no-ff 选项的作用是保留原分支记录</div><div class="line">git branch -d develop       #删除 develop 分支</div></pre></td></tr></table></figure><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><h2 id="显示标签"><a href="#显示标签" class="headerlink" title="显示标签"></a>显示标签</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git tag         #列出现有标签</div><div class="line">git show &lt;tagname&gt;  #显示标签信息</div></pre></td></tr></table></figure><h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git tag v0.1    #新建标签，默认位 HEAD</div><div class="line">git tag v0.1 cb926e7  #对指定的 commit id 打标签</div><div class="line">git tag -a v0.1 -m &apos;version 0.1 released&apos;   #新建带注释标签</div></pre></td></tr></table></figure><h2 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git checkout &lt;tagname&gt;        #切换到标签</div><div class="line">git push origin &lt;tagname&gt;     #推送分支到源上</div><div class="line">git push origin --tags        #一次性推送全部尚未推送到远程的本地标签</div><div class="line">git tag -d &lt;tagname&gt;          #删除标签</div><div class="line">git push origin :refs/tags/&lt;tagname&gt;      #删除远程标签</div><div class="line">Git 设置</div></pre></td></tr></table></figure><p><a href="http://wuchong.me/blog/2015/03/30/git-useful-skills/" target="_blank" rel="external">转载自Jark’s Blog</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;平时一直是用Intellij进行开发,git命令也不会用命令行去输入.导致有些命令都不太熟悉了,每次用到的时候都是google.&lt;br&gt;今天把平时用到的命令做个笔记记录一下.&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="http://dmlcoding.com/categories/git/"/>
    
    
      <category term="git" scheme="http://dmlcoding.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>zabbix 部署文档</title>
    <link href="http://dmlcoding.com/2017/Zabbix/"/>
    <id>http://dmlcoding.com/2017/Zabbix/</id>
    <published>2017-04-20T10:24:00.000Z</published>
    <updated>2017-04-21T08:31:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录下搭建过程,以免以后又重复花时间找搭建文档<br><a id="more"></a></p><h1 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h1><p>搭建是参照这篇博客来搭建的: <a href="http://blog.csdn.net/su1322339466/article/details/53869738" target="_blank" rel="external">http://blog.csdn.net/su1322339466/article/details/53869738</a></p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>安装zabbix_server后,启动 web 页面,默认账号为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">默认账号: Admin</div><div class="line">默认密码: zabbix</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录下搭建过程,以免以后又重复花时间找搭建文档&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://dmlcoding.com/categories/linux/"/>
    
    
      <category term="zabbix" scheme="http://dmlcoding.com/tags/zabbix/"/>
    
  </entry>
  
  <entry>
    <title>saltstack web halite 界面部署文档</title>
    <link href="http://dmlcoding.com/2017/SaltStackWeb/"/>
    <id>http://dmlcoding.com/2017/SaltStackWeb/</id>
    <published>2017-04-15T04:10:00.000Z</published>
    <updated>2017-04-19T09:12:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>安装saltstack webui halite管理界面,方便查看和操作<br>安装部署自动化管理工具SaltStack.在管理多台服务器上,这个工具还是非常好使的,另外由于是 Python写的,也可以很方便的对其进行个性化修改.<br><a id="more"></a></p><h2 id="安装halite"><a href="#安装halite" class="headerlink" title="安装halite"></a>安装halite</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cd /var/www/ </div><div class="line">git clone https://github.com/saltstack/halite</div><div class="line">[root@master halite]# pwd</div><div class="line">/var/www/halite/halite</div><div class="line">[root@master halite]# ./genindex.py -C #生成index.html文件:</div></pre></td></tr></table></figure><h2 id="安装salt-api"><a href="#安装salt-api" class="headerlink" title="安装salt-api"></a>安装salt-api</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install salt-api</div></pre></td></tr></table></figure><h2 id="配置salt-master文件"><a href="#配置salt-master文件" class="headerlink" title="配置salt master文件"></a>配置salt master文件</h2><p>配置salt的master文件，添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[root@master ~]# vim /etc/salt/master</div><div class="line">rest_cherrypy:</div><div class="line"> host: 0.0.0.0</div><div class="line"> port: 8080</div><div class="line"> debug: true</div><div class="line"> static: /var/www/halite/halite</div><div class="line"> app: /var/www/halite/halite/index.html</div><div class="line">external_auth:</div><div class="line">   pam:</div><div class="line">     rui:</div><div class="line">         - .*</div><div class="line">         - &apos;@runner&apos;</div><div class="line">         - &apos;@wheel&apos;</div></pre></td></tr></table></figure></p><h2 id="重启master"><a href="#重启master" class="headerlink" title="重启master"></a>重启master</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@master ~]# /etc/init.d/salt-master restart</div><div class="line">Stopping salt-master daemon: [ OK ]</div><div class="line">Starting salt-master daemon: [ OK ]</div></pre></td></tr></table></figure><h2 id="添加登陆用户"><a href="#添加登陆用户" class="headerlink" title="添加登陆用户"></a>添加登陆用户</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[root@master ~]# useradd rui</div><div class="line">[root@master ~]# passwd rui</div><div class="line">Changing password for user rui.</div><div class="line">New password:</div><div class="line">BAD PASSWORD: it is too short</div><div class="line">BAD PASSWORD: is too simple</div><div class="line">Retype new password:</div><div class="line">passwd: all authentication tokens updated successfully.</div></pre></td></tr></table></figure><h2 id="启动-salt-api"><a href="#启动-salt-api" class="headerlink" title="启动 salt-api"></a>启动 salt-api</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">salt-api -d 或 </div><div class="line">cd /var/www/halite/halite</div><div class="line">python server_bottle.py -d -C -l debug -s cherrypy</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[root@master ~]# cd /var/www/halite/halite/</div><div class="line">[root@master halite]# python server_bottle.py -d -C -l debug -s cherrypy</div><div class="line">20170415_103758.177076 Bottle: Running web application server &apos;cherrypy&apos; on 0.0.0.0:8080.</div><div class="line">20170415_103758.177237 Bottle: CORS is disabled.</div><div class="line">20170415_103758.177289 Bottle: TLS/SSL is disabled.</div><div class="line">20170415_103758.177335 Bottle: Server options:</div><div class="line">&#123;&#125;</div><div class="line">20170415_103758.417684 Bottle: Running web application server &apos;cherrypy&apos; on 0.0.0.0:8080.</div><div class="line">20170415_103758.417833 Bottle: CORS is disabled.</div><div class="line">20170415_103758.417886 Bottle: TLS/SSL is disabled.</div><div class="line">20170415_103758.417931 Bottle: Server options:</div><div class="line">&#123;&#125;</div><div class="line">Bottle v0.12-dev server starting up (using CherryPyServer())...</div><div class="line">Listening on http://0.0.0.0:8080/</div><div class="line">Hit Ctrl-C to quit.</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安装saltstack webui halite管理界面,方便查看和操作&lt;br&gt;安装部署自动化管理工具SaltStack.在管理多台服务器上,这个工具还是非常好使的,另外由于是 Python写的,也可以很方便的对其进行个性化修改.&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="http://dmlcoding.com/categories/python/"/>
    
    
      <category term="python" scheme="http://dmlcoding.com/tags/python/"/>
    
      <category term="saltstack" scheme="http://dmlcoding.com/tags/saltstack/"/>
    
  </entry>
  
</feed>
