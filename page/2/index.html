<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, BigData" />








  <link rel="shortcut icon" type="image/x-icon" href="/images/wei.png?v=5.1.0" />






<meta name="description" content="时间渐行渐远">
<meta property="og:type" content="website">
<meta property="og:title" content="Time渐行渐远">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Time渐行渐远">
<meta property="og:description" content="时间渐行渐远">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Time渐行渐远">
<meta name="twitter:description" content="时间渐行渐远">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title> Time渐行渐远 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Time渐行渐远</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Coding Changing The World</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/01/2016-12-1-SparkExampleCSDN/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hushiwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/wei.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Time渐行渐远">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/01/2016-12-1-SparkExampleCSDN/" itemprop="url">
                  使用Spark分析泄露的2000W开房数据和600W条CSDN用户数据
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-01T14:22:00+08:00">
                2016-12-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spark/" itemprop="url" rel="index">
                    <span itemprop="name">spark</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/12/01/2016-12-1-SparkExampleCSDN/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/01/2016-12-1-SparkExampleCSDN/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="2000W开房数据"><a href="#2000W开房数据" class="headerlink" title="2000W开房数据"></a>2000W开房数据</h2><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><blockquote>
<p>Name,CardNo,Descriot,CtfTp,CtfId,Gender,Birthday,Address,Zip,Dirty,District1,<br>District2,District3,District4,District5,District6,FirstNm,LastNm,Duty,Mobile,Tel,<br>Fax,EMail,Nation,Taste,Education,Company,CTel,CAddress,CZip,Family,Version,id</p>
</blockquote>
<h3 id="数据预览"><a href="#数据预览" class="headerlink" title="数据预览"></a>数据预览</h3><p>为了保护用户隐私,相关数据打码了.</p>
<p><img src="/images/pics/kaifanguser.png" alt="用户数据"></p>
<h3 id="开房数据分析"><a href="#开房数据分析" class="headerlink" title="开房数据分析"></a>开房数据分析</h3><blockquote>
<p>因为是单机local模式运行,用其中一个文件作为测试数据.感兴趣的可以全部加载进来,放在集群里跑一跑.<br>sortbykey是对每个分区中的数据进行排序,如果想要全局排序,把分区数设置为1</p>
</blockquote>
<ul>
<li>分析开房次数TOP10用户(第0,3,4三个字段确定唯一的用户)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">val conf = new SparkConf().setAppName(&quot;KaiFan&quot;).setMaster(&quot;local[*]&quot;)</div><div class="line">val sc = new SparkContext(conf)</div><div class="line">//    酒店开房数据的字段</div><div class="line">//    Name,CardNo,Descriot,CtfTp,CtfId,Gender,Birthday,Address,Zip,Dirty,District1,District2,District3,District4,District5,District6,FirstNm,LastNm,Duty,Mobile,Tel,Fax,EMail,Nation,Taste,Education,Company,CTel,CAddress,CZip,Family,Version,id</div><div class="line">var hotel1RDD = sc.textFile(&quot;G:\\2000W\\1-200W.csv&quot;)</div><div class="line">//    var hotel2RDD = sc.textFile(&quot;G:\\2000W\\200W-400W.csv&quot;)</div><div class="line">//    var hotel3RDD = sc.textFile(&quot;G:\\2000W\\400W-600W.csv&quot;)</div><div class="line">//    var hotel4RDD = sc.textFile(&quot;G:\\2000W\\600W-800W.csv&quot;)</div><div class="line">//    var hotel5RDD = sc.textFile(&quot;G:\\2000W\\800W-1000W.csv&quot;)</div><div class="line">//    var hotel6RDD = sc.textFile(&quot;G:\\2000W\\1000W-1200W.csv&quot;)</div><div class="line">//    var hotel7RDD = sc.textFile(&quot;G:\\2000W\\1200W-1400W.csv&quot;)</div><div class="line">//    var hotel8RDD = sc.textFile(&quot;G:\\2000W\\1400W-1600W.csv&quot;)</div><div class="line">//    var hotel9RDD = sc.textFile(&quot;G:\\2000W\\1600w-1800w.csv&quot;)</div><div class="line">//    var hotel10RDD = sc.textFile(&quot;G:\\2000W\\1800w-2000w.csv&quot;)</div><div class="line"></div><div class="line">//    var hotelRDD = hotel1RDD ++ hotel2RDD ++ hotel3RDD ++ hotel4RDD ++ hotel5RDD ++ hotel6RDD ++ hotel7RDD ++ hotel8RDD ++ hotel9RDD ++ hotel10RDD</div><div class="line">var hotelRDD = hotel1RDD</div><div class="line"></div><div class="line">//    分析开房次数TOP10用户(第0,3,4三个字段确定唯一的用户)</div><div class="line">val tmpRDD=hotelRDD.map(line=&gt;line.toString().split(&quot;,&quot;)).filter(_.length==33)</div><div class="line">val result=tmpRDD.map(arr=&gt; (arr(0),arr(3),arr(4))).map(arr=&gt;(arr,1)).reduceByKey(_+_).sortBy(arr=&gt;arr._2,false)</div><div class="line">result.take(10).foreach(println)</div></pre></td></tr></table></figure>
<ul>
<li>统计一天中,各个小时离店的人数</li>
</ul>
<p>先去除脏数据,然后从时间字段里过滤出小时部分.然后统计小时的词频</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">val hourRDD = hotelRDD.map(line =&gt; line.toString().split(&quot;,&quot;)).filter(_.length == 33).filter(arr =&gt; arr(31).trim.length != 0)</div><div class="line">  .map(arr =&gt; arr(31)).map(str =&gt; str.split(&quot;[- :]&quot;)).filter(arr =&gt; arr.length == 6)</div><div class="line">  .map(arr =&gt; arr(3).toInt).map(hour =&gt; (hour, 1)).reduceByKey(_ + _).map &#123; case (x, y) =&gt; (y, x)&#125;</div><div class="line"></div><div class="line">  // 用sortbykey进行排序,然后再取前10</div><div class="line">val sortedHourRDD=hourRDD.sortByKey(false, 1)</div><div class="line">sortedHourRDD.take(10).foreach(println)</div><div class="line"></div><div class="line">println(&quot;--------------------------------&quot;)</div><div class="line">// 对未排序的序列,调用top(n)算子,底层帮你排序,然后取topn数据.</div><div class="line">hourRDD.top(10).foreach(println)</div></pre></td></tr></table></figure>
<ul>
<li>性别分布统计</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//    性别分布统计</div><div class="line">    val sexRDD=hotelRDD.map(line=&gt; line.toString().split(&quot;,&quot;)).filter(_.length==33).filter(arr=&gt;arr(31).trim.length!=0)</div><div class="line">      .map(arr=&gt;arr(5))</div><div class="line">//      过滤掉脏数据</div><div class="line">      .filter(_.trim.length==1)</div><div class="line">      .filter(sex=&gt;(sex==&quot;F&quot; || sex==&quot;M&quot;))</div><div class="line">      .map((_,1))</div><div class="line">//      对性别字段进行统计</div><div class="line">      .reduceByKey(_+_)</div><div class="line"></div><div class="line">    sexRDD.foreach(println)</div></pre></td></tr></table></figure>
<ul>
<li>开房的年龄分布</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//    年龄分布统计(从身份证中截取出身年份,然后用今年减去即可)</div><div class="line">val ageRDD = hotelRDD.map(line =&gt; line.toString().split(&quot;,&quot;)).filter(_.length == 33)</div><div class="line">  .filter(arr =&gt; arr(3) == &quot;ID&quot;) //只取ID类型的用户</div><div class="line">  .filter(arr =&gt; arr(4).length == 18) //确保身份证号的位数是对的</div><div class="line">  .map(_ (4))</div><div class="line">  .filter(&quot;^[1-9]\\d&#123;5&#125;[1-9]\\d&#123;3&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;([0-9]|X)$&quot;.r.pattern.matcher(_).matches())</div><div class="line">  .map(num =&gt; num.substring(6, 10)) // 取出年份</div><div class="line">  .map(2016 - _.toInt)</div><div class="line">  .filter(age =&gt; (age &gt; 0 &amp;&amp; age &lt; 110))</div><div class="line">  .map((_, 1))</div><div class="line">  .reduceByKey(_ + _)</div><div class="line">  .map &#123; case (x, y) =&gt; (y, x) &#125;</div><div class="line">  .sortByKey(false, 1)</div><div class="line"></div><div class="line">println(ageRDD.count())</div><div class="line">ageRDD.foreach(println)</div></pre></td></tr></table></figure>
<h2 id="CSDN用户数据分析"><a href="#CSDN用户数据分析" class="headerlink" title="CSDN用户数据分析"></a>CSDN用户数据分析</h2><h3 id="数据格式预览"><a href="#数据格式预览" class="headerlink" title="数据格式预览"></a>数据格式预览</h3><blockquote>
<p>以免泄露别人的信息,以下的信息我做了额外的增加</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">zdgs # 12344fd321 # zdfdag@csdn.net</div><div class="line">LaafoZheng # 6702fsd03313747 # chenfdagming_zheng@163.com</div><div class="line">fstfaao # 730df413 # fstafao@tom.com</div><div class="line">hufdwolf # 25352gf63 # hujiadfye@263.net</div><div class="line">cafaddcjl # KIC43aafdk6! # ccegfdsdcjl@21cn.com</div></pre></td></tr></table></figure>
<h3 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h3><ul>
<li>分析最多人使用的TOPn个密码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">val csdnRDD = sc.textFile(&quot;G:\\600W-CSDN\\csdnuser.txt&quot;)</div><div class="line">println(s&quot;csdn一共泄露了: $&#123;csdnRDD.count()&#125; 个用户数据&quot;)</div><div class="line">//     cafaddcjl # KIC43aafdk6! # ccegfdsdcjl@21cn.com</div><div class="line">//    分析最多人使用的TOPn个密码</div><div class="line">val pwRDD = csdnRDD.map(line =&gt; line.toString.split(&quot; # &quot;))</div><div class="line">  .map(_ (1))</div><div class="line">  .map((_, 1)).reduceByKey(_ + _)</div><div class="line">  .map &#123; case (x, y) =&gt; (y, x) &#125;.sortByKey(false)</div><div class="line">  .map &#123; case (x, y) =&gt; (y, x) &#125;</div><div class="line">println(&quot;最常用的前50个密码: &quot;)</div><div class="line">pwRDD.take(50).foreach(println)</div></pre></td></tr></table></figure>
<ul>
<li>统计使用纯数字作为密码的人数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">val numPwRDD = csdnRDD.map(line =&gt; line.toString.split(&quot; # &quot;))</div><div class="line">  .map(_ (1))</div><div class="line">  .filter(&quot;\\d+&quot;.r.pattern.matcher(_).matches())</div><div class="line">  .map((_, 1)).reduceByKey(_ + _).sortBy(_._2, false)</div><div class="line">println(&quot;最常用的前20个纯数字密码: &quot;)</div><div class="line">numPwRDD.take(20).foreach(println)</div></pre></td></tr></table></figure>
<p><img src="/images/pics/numPW.png" alt="数字密码"></p>
<ul>
<li>统计使用纯字母作为密码的人数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">val letterRDD = csdnRDD.map(line =&gt; line.toString.split(&quot; # &quot;))</div><div class="line">  .map(_ (1))</div><div class="line">  .filter(&quot;[a-zA-Z]+&quot;.r.pattern.matcher(_).matches())</div><div class="line">  .map((_, 1)).reduceByKey(_ + _).sortBy(_._2, false)</div><div class="line">println(&quot;最常用的前20个纯字母密码: &quot;)</div><div class="line">letterRDD.take(20).foreach(println)</div></pre></td></tr></table></figure>
<p><img src="/images/pics/letterPW.png" alt="字母密码"></p>
<hr>
<ul>
<li>声明:<ul>
<li>统计指标来源与网络上的博客</li>
<li>数据也来自于网络,想要数据的可以联系我</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/27/2016-11-27-VPSInstallJekyll/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hushiwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/wei.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Time渐行渐远">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/27/2016-11-27-VPSInstallJekyll/" itemprop="url">
                  在VPS上安装Jekyll,搭建自己的静态博客
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-27T17:24:00+08:00">
                2016-11-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vps/" itemprop="url" rel="index">
                    <span itemprop="name">vps</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/11/27/2016-11-27-VPSInstallJekyll/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/27/2016-11-27-VPSInstallJekyll/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Jekyll是什么？"><a href="#Jekyll是什么？" class="headerlink" title="Jekyll是什么？"></a>Jekyll是什么？</h1><blockquote>
<p>jekyll可以将纯文本转化为静态网站和博客。</p>
</blockquote>
<p>Jekyll具体可以做什么，不在本文的讨论范围内，有兴趣的可以去官网上看看帮助文档。<br><a href="http://jekyll.com.cn/" target="_blank" rel="external">Jekyll官网</a></p>
<h1 id="安装Jekyll的过程"><a href="#安装Jekyll的过程" class="headerlink" title="安装Jekyll的过程"></a>安装Jekyll的过程</h1><blockquote>
<p>环境：本教程是在VPS的CentOS6.5上搭建的</p>
</blockquote>
<h2 id="1-安装Ruby"><a href="#1-安装Ruby" class="headerlink" title="1.安装Ruby"></a>1.安装Ruby</h2><h3 id="1-1-安装rvm-然后通过rvm安装较新版本的Ruby"><a href="#1-1-安装rvm-然后通过rvm安装较新版本的Ruby" class="headerlink" title="1.1 安装rvm,然后通过rvm安装较新版本的Ruby"></a>1.1 安装rvm,然后通过rvm安装较新版本的Ruby</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3</div><div class="line"></div><div class="line">curl -sSL https://get.rvm.io | bash -s stable</div><div class="line"></div><div class="line">source /etc/profile.d/rvm.sh</div></pre></td></tr></table></figure>
<h3 id="1-2-安装ruby-2-2-1"><a href="#1-2-安装ruby-2-2-1" class="headerlink" title="1.2 安装ruby 2.2.1"></a>1.2 安装ruby 2.2.1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo yum install libyaml</div><div class="line"></div><div class="line">rvm install 2.2.1</div></pre></td></tr></table></figure>
<h3 id="1-3-设为默认版本"><a href="#1-3-设为默认版本" class="headerlink" title="1.3 设为默认版本"></a>1.3 设为默认版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rvm use 2.2.1 --default</div></pre></td></tr></table></figure>
<h2 id="2-安装-Nodejs"><a href="#2-安装-Nodejs" class="headerlink" title="2.安装 Nodejs"></a>2.安装 Nodejs</h2><blockquote>
<p>Jekyll 依赖 JavaScript 运行时库，需要安装 Nodejs</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sudo rpm -ivh http://mirrors.zju.edu.cn/epel/6/i386/epel-release-6-8.noarch.rpm</div><div class="line"></div><div class="line">sudo yum update</div><div class="line"></div><div class="line">sudo yum install nodejs</div></pre></td></tr></table></figure>
<h2 id="3-安装-Jekyll"><a href="#3-安装-Jekyll" class="headerlink" title="3.安装 Jekyll"></a>3.安装 Jekyll</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gem install jekyll</div></pre></td></tr></table></figure>
<h2 id="4-测试是否成功"><a href="#4-测试是否成功" class="headerlink" title="4.测试是否成功"></a>4.测试是否成功</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">jekyll new blog</div><div class="line"></div><div class="line">cd blog</div><div class="line"></div><div class="line">jekyll serve --host 0.0.0.0</div></pre></td></tr></table></figure>
<p>然后在浏览器中打开 http://&lt;外网 IP 地址&gt;:4000，应能看到 Jekyll 默认页面。</p>
<h2 id="5-搭建自己的静态博客"><a href="#5-搭建自己的静态博客" class="headerlink" title="5.搭建自己的静态博客"></a>5.搭建自己的静态博客</h2><blockquote>
<p>做好上述的准备后,就可以着手搭建自己的博客了.</p>
</blockquote>
<h3 id="5-1-如果你会前端"><a href="#5-1-如果你会前端" class="headerlink" title="5.1 如果你会前端"></a>5.1 如果你会前端</h3><p>那么你可以自己写页面或者修改别人写的模板.</p>
<h3 id="5-2-如果你不会前端"><a href="#5-2-如果你不会前端" class="headerlink" title="5.2 如果你不会前端"></a>5.2 如果你不会前端</h3><p>像我这样不会前端的,那么可以在网上找些Jekyll的模板,然后套上去就可以用了.</p>
<h2 id="6-如何套上模板"><a href="#6-如何套上模板" class="headerlink" title="6. 如何套上模板"></a>6. 如何套上模板</h2><h3 id="6-1-Jekyll主题介绍"><a href="#6-1-Jekyll主题介绍" class="headerlink" title="6.1 Jekyll主题介绍"></a>6.1 Jekyll主题介绍</h3><p>如图<br><img src="/images/pics/Jekyll.png" alt="Jekyll主题"></p>
<p>我们主要知道这三个地方就行了,有兴趣的也可以把所有的内容都看看.做到心里有数.</p>
<ul>
<li>_post:在这个路径下放你写的博客就行了.要注意命名规则和博客的handle规则.这些Jekyll的官网都有说明.不会博客可能不会显示出来.</li>
<li>page:这个页面下放的是你的博客有几个tab页.</li>
<li>_config.yml:关于Jekyll静态博客,所有的可配参数,都可以在这个配置文件中进行修改.</li>
</ul>
<h3 id="6-2-启动博客"><a href="#6-2-启动博客" class="headerlink" title="6.2 启动博客"></a>6.2 启动博客</h3><p>把你的博客工程放到你的装好了Jekyll的VPS服务器上后,进入这个目录.用下面的几个命令就完事了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">启动你的博客,让任何主机都可以访问(--detach 表示后台运行):</div><div class="line">jekyll serve --detach  --host 0.0.0.0</div><div class="line"></div><div class="line">当修改了博客,或者添加了博文的时候,需要先关闭在后台运行的博客服务.</div><div class="line"></div><div class="line">查找博客进程,第一个就是,第二个是Jekyll服务,不用kill:</div><div class="line">ps aux | grep jekyll</div><div class="line"></div><div class="line">关闭上面查到的第一个进程就行了:</div><div class="line">kill -9 pid</div></pre></td></tr></table></figure>
<p>现在你在浏览器上就可以通过Ip+端口访问了.</p>
<h3 id="6-3-购买域名-修改默认端口"><a href="#6-3-购买域名-修改默认端口" class="headerlink" title="6.3 购买域名+修改默认端口"></a>6.3 购买域名+修改默认端口</h3><h4 id="6-3-1-购买域名"><a href="#6-3-1-购买域名" class="headerlink" title="6.3.1 购买域名"></a>6.3.1 购买域名</h4><p>根据自己的需要购买自己的域名,价格根据你的选择而来的.我是在阿里云上买的.<br><a href="https://wanwang.aliyun.com/" target="_blank" rel="external">购买域名的地址</a></p>
<p>买好域名后,再把域名和IP绑定,做好映射.买的时候注意看,会有引导步骤.</p>
<h4 id="6-3-2-修改默认端口"><a href="#6-3-2-修改默认端口" class="headerlink" title="6.3.2 修改默认端口"></a>6.3.2 修改默认端口</h4><blockquote>
<p>Jekyll的默认端口是4000.但是浏览器访问的默认端口是80.为了省去别人访问你的博客的时候还得写端口.我们需要把Jekyll的默认端口修改为80</p>
</blockquote>
<p>1.查看监听80端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@bigdata ~]# netstat -nat | grep &apos;:80&apos;</div><div class="line">tcp        0      0 0.0.0.0:80                  0.0.0.0:*                   LISTEN</div></pre></td></tr></table></figure>
<p>2.如果显示listen表示正在运行,那么我们需要先关闭被占用的80端口.切换到/etc/init.d服务启动脚本下面查看.(httpd就是了)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@bigdata init.d]# cd /etc/init.d/</div><div class="line">[root@bigdata init.d]# ls</div><div class="line">crond         httpd      modules_dep  network      quota_nld    rsyslog    single     sshd</div><div class="line">functions     ip6tables  named        nmb          rdisc        sandbox    smb        udev-post</div><div class="line">halt          iptables   netconsole   nscd         restorecond  saslauthd  snmpd      winbind</div><div class="line">htcacheclean  killall    netfs        portreserve  rpcbind      sendmail   snmptrapd  xinetd</div></pre></td></tr></table></figure>
<p>3.找到占用80服务的端口之后,通过命令关闭80端口.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@bigdata ~]# /etc/init.d/httpd stop</div></pre></td></tr></table></figure>
<p>4.再次查看端口使用情况,已经没有80在使用了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@bigdata ~]# netstat -nat | grep &apos;:80&apos;</div><div class="line">[root@bigdata ~]#</div></pre></td></tr></table></figure>
<p>5.那么就可以把Jekyll的默认端口改成80就完事了.</p>
<p>修改你的模板下的_config.yml文件,在里面加上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">port: 80</div></pre></td></tr></table></figure>
<p>6.然后上传你的工程到VPS下,启动你的博客就行了,若是域名配好了,那么就可以用域名访问了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@bigdata dmlBlog]# jekyll serve --detach  --host 0.0.0.0</div></pre></td></tr></table></figure>
<p><a href="http://www.dmlcoding.com/" target="_blank" rel="external">我的博客</a></p>
<p>完成了….</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/27/2016-11-27-Recursion/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hushiwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/wei.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Time渐行渐远">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/27/2016-11-27-Recursion/" itemprop="url">
                  递归算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-27T09:50:00+08:00">
                2016-11-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/11/27/2016-11-27-Recursion/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/27/2016-11-27-Recursion/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="递归与堆栈"><a href="#递归与堆栈" class="headerlink" title="递归与堆栈"></a>递归与堆栈</h1><h2 id="递归的概念"><a href="#递归的概念" class="headerlink" title="递归的概念"></a>递归的概念</h2><p><strong>递归:</strong> 是指在定义自身的同时又出现对自身的引用.如果一个算法直接或间接地调用自己,则称这个算法是一个递归算法.</p>
<p><strong>递归组成:</strong> 任何一个有意义的递归算法总是由两部分组成:递归调用与递归终止条件.</p>
<ul>
<li>递归组成<ul>
<li>递归调用</li>
<li>递归终止条件</li>
</ul>
</li>
</ul>
<h2 id="递归的实例"><a href="#递归的实例" class="headerlink" title="递归的实例"></a>递归的实例</h2><h3 id="求N的阶乘"><a href="#求N的阶乘" class="headerlink" title="求N的阶乘"></a>求N的阶乘</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">    public static void main(String[] args) &#123;</div><div class="line">//        求n的阶乘</div><div class="line">        int sum = factorial(4);</div><div class="line">        System.out.println(sum);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static int factorial(int n) &#123;</div><div class="line">        if (n==1) &#123; // 递归终止条件</div><div class="line">            return 1;</div><div class="line">        &#125;else&#123;</div><div class="line">            return n * factorial(n - 1); //递归调用</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>从代码中可以看出,在编写递归算法时,一定要注意有递归调用和递归终止条件.如果没有递归终止条件,那么将无休止的进行下去,直到溢出.如果没有递归调用,<br>那么就不是一个递归算法.</p>
<h2 id="递归的实现与堆栈"><a href="#递归的实现与堆栈" class="headerlink" title="递归的实现与堆栈"></a>递归的实现与堆栈</h2><blockquote>
<p>我们知道在递归算法中会递归调用自身,因此在递归算法的执行过程中会多次进行自我调用.那么这个调用过程是如何实现的呢?</p>
</blockquote>
<p>为了说明自身的递归调用,我们先看任意两个函数之间进行调用的情形.</p>
<p>通常在<strong>一个函数</strong>执行过程中需要调用<strong>另一个函数</strong>时,在运行被调用函数之前系统通常需要完成如下工作:</p>
<ul>
<li>1.对调用函数的运行现场进行保护,主要是参数与返回地址等信息的保存;</li>
<li>2.创建被调用函数的运行环境;</li>
<li>3.将程序控制转移到调用函数的入口.</li>
</ul>
<p>在被调用函数执行结束之后,返回调用函数之前,系统同样需要完成3件工作:</p>
<ul>
<li>1.保存被调函数的返回结果;</li>
<li>2.释放被调用函数的数据区;</li>
<li>3.依照保存的调用函数的返回地址将程序控制转移到调用函数.</li>
</ul>
<p><strong>注意:</strong></p>
<p>1.如果上述函数调用的过程中发生了新的调用,也就是被调函数在执行完成之前又调用了其他函数, 此时构成了多个函数的<strong>嵌套调用</strong>.<br>2.当发生嵌套调用时按照<strong>后调用先返回</strong>的原则处理,如此则形成了一个保存函数运行时环境变量的<strong>后进先出</strong>的使用过程.<br>3.因此整个函数调用期间的相关信息的保存需要一个堆栈来实现.<br>4.系统在整个运行时需要的数据空间安排在一个堆栈中.<br>    4.1每当调用一个函数时就为它在栈顶分配一个存储区;<br>    4.2每当从一个函数返回时就释放它的存储区.</p>
<h2 id="从底层过程理解递归调用"><a href="#从底层过程理解递归调用" class="headerlink" title="从底层过程理解递归调用"></a>从底层过程理解递归调用</h2><blockquote>
<p>从上一节我们明白了函数之间是如何调用的了.那么一个递归算法的实现实际上就是多个相同函数的嵌套调用.</p>
</blockquote>
<p>对上面N阶乘法的例子,具体说明,看图</p>
<p><img src="/images/pics/factorial.png" alt="递归阶乘"></p>
<p>从上图,我们知道了递归算法的实现原理.后调用的先返回,因此我们就是从递归的终止条件开始层层往上返回.再次说明了,递归算法必须得有终止条件.</p>
<p><strong>但是:</strong> 我们也看到了递归算法在某些情况下并不一定是最高效的方法,主要原因在于递归方法过于频繁的函数调用和参数传递,这会使系统有较大的开销.在某些情况下,采用循环或递归算法的非递归实现,将会大大提高算法的实际执行效率.</p>
<h1 id="基于归纳的递归"><a href="#基于归纳的递归" class="headerlink" title="基于归纳的递归"></a>基于归纳的递归</h1><blockquote>
<p>基于归纳的递归是一种较为简单并且也是一种基本的递归算法设计方法.它的主要思想是把数学归纳法应用于算法设计之中.</p>
</blockquote>
<p>可以看看wiki上关于数学归纳法的解释,明白什么是数学归纳法,如何与递归结合起来.<br><a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95" target="_blank" rel="external">WIKI-数学归纳法</a></p>
<h2 id="数学归纳法–-gt-递归"><a href="#数学归纳法–-gt-递归" class="headerlink" title="数学归纳法–&gt;递归"></a>数学归纳法–&gt;递归</h2><blockquote>
<p>从数学归纳法的思路推导到递归的算法思想</p>
</blockquote>
<p><img src="/images/pics/guinafa.png" alt="数学归纳法到递归的转变"></p>
<p>比如这个经典的例子</p>
<p><img src="/images/pics/hanomi.png" alt="汉诺米塔"></p>
<p><strong>在这个例子里面,我们主要是要理解数学归纳法的思想和递归的思想是如何联系在一起的</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/23/2016-11-23-DecisitionTree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hushiwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/wei.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Time渐行渐远">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/23/2016-11-23-DecisitionTree/" itemprop="url">
                  决策树
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-23T06:25:00+08:00">
                2016-11-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MachineLearning/" itemprop="url" rel="index">
                    <span itemprop="name">MachineLearning</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/11/23/2016-11-23-DecisitionTree/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/23/2016-11-23-DecisitionTree/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是决策树"><a href="#什么是决策树" class="headerlink" title="什么是决策树"></a>什么是决策树</h1><h2 id="决策树的概念"><a href="#决策树的概念" class="headerlink" title="决策树的概念"></a>决策树的概念</h2><p> 如图1:</p>
<p> <img src="/images/pics/decisitionTreeBasic.png" alt="decisitionTreeBasic"></p>
<p>图1中就是一个决策树,长方形代表判断模块,椭圆形代表终止模块,表示已经得出结论,可以终止运行.从判断模块引出的左右箭头称作分支.<br>它可以到达另一个判断模块或者终止模块.</p>
<h2 id="决策树的特点"><a href="#决策树的特点" class="headerlink" title="决策树的特点"></a>决策树的特点</h2><ul>
<li>优点:计算复杂度不高,输出结果易于理解,对中间值的缺失不敏感,可以处理不相关特征数据  </li>
<li>缺点:可能会产生过度匹配问题  </li>
<li>使用数据类型:数值型和标称型  </li>
</ul>
<h2 id="决策树的一般流程"><a href="#决策树的一般流程" class="headerlink" title="决策树的一般流程"></a>决策树的一般流程</h2><ul>
<li>收集数据:可以使用任何方法  </li>
<li>准备数据:树构造算法只适用于标称型数据,因此数值型数据必须离散化  </li>
<li>分析数据:可以使用任何方法  </li>
</ul>
<p>构造树完成之后,我们应该检查图形是否符合预期</p>
<ul>
<li>训练算法:构造树的数据结构</li>
<li>测试算法:使用经验树计算错误率</li>
<li>使用算法:此步骤可以适用于任何监督学习算法</li>
</ul>
<h1 id="如何构建决策树"><a href="#如何构建决策树" class="headerlink" title="如何构建决策树"></a>如何构建决策树</h1><blockquote>
<p>接下来我们将学习如何从一堆原始数据中构造决策树</p>
</blockquote>
<h2 id="计算信息增益来度量信息"><a href="#计算信息增益来度量信息" class="headerlink" title="计算信息增益来度量信息"></a>计算信息增益来度量信息</h2><blockquote>
<p>我们需要解决的第一个问题就是,当前数据集上哪个特征在划分数据分类时起决定性作用.为了找到决定性的特征,划分出最好的结果,<br>我们必须评估每个特征.</p>
</blockquote>
<h3 id="如何对数据进行评估"><a href="#如何对数据进行评估" class="headerlink" title="如何对数据进行评估"></a>如何对数据进行评估</h3><p>划分数据集的最大原则是:将无序的数据变得更加有序.<br>因此,我们可以在划分数据前后使用信息论量化度量信息的内容.在划分数据集之前之后信息发生的变化称为<strong>信息增益</strong>,<br>知道如何计算信息增益,我们就可以计算每个特征划分数据集获得的信息增益,或得信息增益最高的特征就是最好的选择.</p>
<p><strong>集合信息的度量方式称为香农熵或者简称熵(这个名字来源于信息论之父克劳德-香农)</strong></p>
<p>熵定义为信息的期望值,在明晰这个概念之前,我们必须知道信息的定义.<br>信息的定义:如果待分类的事物可能划分在多个分类之中,则符号Xi的信息定义为</p>
<p><img src="/images/pics/xinxi.png" alt="信息"></p>
<p>其中P(Xi)是选择该分类的概率.</p>
<p>为了计算熵,我们需要计算所有类别所有可能值包含的信息期望值,通过下面的公式得到:</p>
<p><img src="/images/pics/shang.png" alt="熵"></p>
<p>其中n类是分类的数目</p>
<h3 id="计算给定数据集的香农熵"><a href="#计算给定数据集的香农熵" class="headerlink" title="计算给定数据集的香农熵"></a>计算给定数据集的香农熵</h3><blockquote>
<p>利用上面的公式,对数据集求香农熵,得出信息增益,度量信息量</p>
</blockquote>
<p>1.计算有多少行<br>2.对每一行的最后一个label进行统计.(用一个字典可以方便的解决这个问题,key是label,value是次数)<br>3.对每个label求概率<br>4.运用熵公式求值</p>
<p>先创建一个数据集</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">def createDataSet():</div><div class="line">    dataSet=[[1,1,&apos;maybe&apos;],</div><div class="line">             [1,1,&apos;yes&apos;],</div><div class="line">             [1,0,&apos;no&apos;],</div><div class="line">             [0,1,&apos;no&apos;],</div><div class="line">             [0,1,&apos;no&apos;]]</div><div class="line">    labels=[&apos;no surfacing&apos;,&apos;flippers&apos;]</div><div class="line">    return dataSet,labels</div></pre></td></tr></table></figure>
<p>步入正题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">from math import log</div><div class="line"></div><div class="line">def calcShannonEnt(dataSet):</div><div class="line">    numEntries=len(dataSet)</div><div class="line">    labelCounts=&#123;&#125;</div><div class="line">    for featVec in dataSet:</div><div class="line">        currentLable=featVec[-1]</div><div class="line">        if currentLable not in labelCounts.keys():</div><div class="line">            labelCounts[currentLable]=0</div><div class="line">        labelCounts[currentLable]+=1</div><div class="line">    shannonEnt=0.0</div><div class="line">    for key in labelCounts:</div><div class="line">        prob=float(labelCounts[key])/numEntries</div><div class="line">        shannonEnt-=prob*log(prob,2)</div><div class="line">    return shannonEnt</div></pre></td></tr></table></figure>
<p><strong>注意</strong>:求出的熵值越高,表示混合的数据也越多.也就是这个数据集中的分类也越多.</p>
<h2 id="合理划分数据集"><a href="#合理划分数据集" class="headerlink" title="合理划分数据集"></a>合理划分数据集</h2><blockquote>
<p>得到熵之后,我们就可以按照获取最大信息增益的方法划分数据集.</p>
</blockquote>
<p>我们将对每个特征划分数据集的结果计算一次信息熵.然后判断按照哪个特征划分数据集是最好的划分方式.<br>也就是对划分后的数据集求信息熵,熵值越小,表示数据划分的越好.</p>
<h3 id="划分数据集"><a href="#划分数据集" class="headerlink" title="划分数据集"></a>划分数据集</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">def splitDataSet(dataSet,axis,values):</div><div class="line">    retDataSet=[]</div><div class="line">    for featVec in dataSet:</div><div class="line">        if featVec[axis]==values:</div><div class="line">            reducedFeatVec=featVec[:axis]</div><div class="line">            reducedFeatVec.extend(featVec[axis+1:])</div><div class="line">            retDataSet.append(reducedFeatVec)</div><div class="line">    return retDataSet</div></pre></td></tr></table></figure>
<p>说明:该代码需要三个参数</p>
<ul>
<li>参数1:数据集</li>
<li>参数2:axis是按照第几个特征划分</li>
<li>参数3:values是该特征的值</li>
</ul>
<p>我们要遍历数据集中的每个元素,一旦发现符合要求的值,则将其添加到新创建的列表中.<br>这里要注意python中,对列表操作的两个方法的不同之处.extend和append</p>
<h3 id="选择最好的数据集划分方式"><a href="#选择最好的数据集划分方式" class="headerlink" title="选择最好的数据集划分方式"></a>选择最好的数据集划分方式</h3><blockquote>
<p>接下来我们遍历整个数据集,循环计算香农熵和splitDataSet()函数,找到最好的特征划分方式.<br>熵计算将会告诉我们如何划分数据集是最好的数据组织方式.</p>
</blockquote>
<p>数据需要满足的要求:</p>
<ul>
<li>1.数据必须是一种由列表元素组成的列表,而且所有的列表元素都要具有相同的数据长度.</li>
<li>2.数据的最后一列或者每个实例的最后一个元素是当前实例的类别标签.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">def chooseBestFeatureToSplit(dataSet):</div><div class="line">    # 返回一共有几个特征</div><div class="line">    numFeatures=len(dataSet[0])-1</div><div class="line">    baseEntropy=calcShannonEnt(dataSet)</div><div class="line">    bestInfoGain=0.0</div><div class="line">    bestFeature=-1</div><div class="line">    # 遍历特征,一个特征一个特征的来处理</div><div class="line">    for i in range(numFeatures):</div><div class="line">        featList=[example[i] for example in dataSet]</div><div class="line">        print &quot;featList \n&quot;,featList</div><div class="line">        uniqueVals=set(featList)</div><div class="line">        newEntropy=0.0</div><div class="line"></div><div class="line">        # 对该特征的所有可能取值的方式进行划分,然后求信息熵,最后把该特征的信息增益求出来</div><div class="line">        for value in uniqueVals:</div><div class="line">            # 对每个特征的不同值进行划分数据</div><div class="line">            subDataSet=splitDataSet(dataSet,i,value)</div><div class="line">            prob=len(subDataSet)/float(len(dataSet))</div><div class="line">            newEntropy+=prob*calcShannonEnt(subDataSet)</div><div class="line">        infoGain=baseEntropy-newEntropy</div><div class="line">        # 信息增益越大,说明用该特征划分的数据集计算出的信息熵越小,也就是划分的越好.</div><div class="line">        # 在此跟上一次的划分进行比较,得出最合适的特质</div><div class="line">        if (infoGain&gt;bestInfoGain):</div><div class="line">            bestInfoGain=infoGain</div><div class="line">            bestFeature=i</div><div class="line">    return bestFeature</div></pre></td></tr></table></figure>
<h2 id="递归构建决策树"><a href="#递归构建决策树" class="headerlink" title="递归构建决策树"></a>递归构建决策树</h2><blockquote>
<p>有了上面的准备后,我们要开始把上面的方法组合起来,构建决策树了.</p>
</blockquote>
<p>目前我们已经知道了从数据集构建决策树算法所需要的子功能模块,其工作原理如下:<br>得到原始数据集,然后基于最好的属性值划分数据集,由于特征值可能多于两个,因此可能存在大于两个分支的数据集划分.<br>第一次划分后,数据将被向下传递到树分支的下一个节点,在这个节点上,我们可以再次划分数据.因此我们可以采用递归的原则处理数据集.<br>递归结束的条件是:<br>程序遍历完所有划分数据集的属性,或者每个分支下的所有实例都具有相同的分类,则得到一个叶子节点或者终止块.<br><strong>任何到达叶子节点的数据必然属于叶子节点的分类</strong></p>
<p><img src="/images/pics/tree.png" alt="tree"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">def majorityCnt(classList):</div><div class="line">    classCount=&#123;&#125;</div><div class="line">    for vote in classList:</div><div class="line">        if vote not in classCount.keys():classCount[vote]=0</div><div class="line">        classCount[vote]+=1</div><div class="line">    sortedClassCount=sorted(classCount.iteritems(),key=operator.itemgetter(1),reverse=True)</div><div class="line">    return sortedClassCount[0][0]</div><div class="line"></div><div class="line">def createTree(dataSet,labels):</div><div class="line">    # 获取该数据集的所有label,存放到一个列表中</div><div class="line">    classList=[example[-1] for example in dataSet]</div><div class="line">    # 判断:如果在这个数据集的列表中,第一个元素的个数和这个列表的元素个数相等.说明这个数据集已经划分完全了.</div><div class="line">    if classList.count(classList[0])==len(classList):</div><div class="line">        return classList[0]</div><div class="line">    if len(dataSet[0])==1:</div><div class="line">        return majorityCnt(classList)</div><div class="line">    # 获取最合适的分类特征</div><div class="line">    bestFeat=chooseBestFeatureToSplit(dataSet)</div><div class="line">    #</div><div class="line">    bestFeatLabel=labels[bestFeat]</div><div class="line">    myTree=&#123;bestFeatLabel:&#123;&#125;&#125;</div><div class="line">    # 得到列表包含的所有属性值</div><div class="line">    del(labels[bestFeat])</div><div class="line">    featValues=[example[bestFeat] for example in dataSet]</div><div class="line">    uniqueVals=set(featValues)</div><div class="line">    for value in uniqueVals:</div><div class="line">        subLabels=labels[:]</div><div class="line">        myTree[bestFeatLabel][value]=createTree(splitDataSet(dataSet,bestFeat,value),subLabels)</div><div class="line">    return myTree</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/22/2016-11-22-VPSshadowsocks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hushiwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/wei.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Time渐行渐远">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/22/2016-11-22-VPSshadowsocks/" itemprop="url">
                  VPS服务器搭建Shadowsocks服务
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-22T14:23:22+08:00">
                2016-11-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/shadowsocks/" itemprop="url" rel="index">
                    <span itemprop="name">shadowsocks</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/11/22/2016-11-22-VPSshadowsocks/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/22/2016-11-22-VPSshadowsocks/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="购买自己的VPS服务器"><a href="#购买自己的VPS服务器" class="headerlink" title="购买自己的VPS服务器"></a>购买自己的VPS服务器</h1><h2 id="购买渠道"><a href="#购买渠道" class="headerlink" title="购买渠道"></a>购买渠道</h2><ul>
<li>1.<a href="http://banwagong.cn/fangan.html" target="_blank" rel="external">http://banwagong.cn/fangan.html</a></li>
<li>2.<a href="https://hostodo.com/vz.html" target="_blank" rel="external">https://hostodo.com/vz.html</a></li>
</ul>
<p>我就只在这两个网站上买过VPS.<br>第一个网站是搬瓦工，好处是可以支付宝支付。最低的包年配置啥的还能接受。搭个梯子，建个blog没啥问题。<br>第二个网站的包年vps的配置比搬瓦工的要好一点，而且价格差不多便宜一半。可惜是不能支付宝支付。</p>
<h1 id="有了VPS后，在VPS上搭建ShadowSocks"><a href="#有了VPS后，在VPS上搭建ShadowSocks" class="headerlink" title="有了VPS后，在VPS上搭建ShadowSocks"></a>有了VPS后，在VPS上搭建ShadowSocks</h1><blockquote>
<p>shadowsocks 是一个轻量级隧道代理，用来穿过防火墙。</p>
</blockquote>
<p>我的VPS机器安装的是CentOS系统、所以下面的操作都是以CentOS为准、当然你要是用RedHat也是一样的操作方式。</p>
<h2 id="1-安装Setuptools"><a href="#1-安装Setuptools" class="headerlink" title="1.安装Setuptools"></a>1.安装Setuptools</h2><ul>
<li>1.先下载Setuptools的egg安装包</li>
<li>2.然后设置运行权限</li>
<li>3.最后./运行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">wget --no-check-certificate https://pypi.python.org/packages/2.6/s/setuptools/setuptools-0.6c11-py2.6.egg</div><div class="line"></div><div class="line">chmod +x setuptools-0.6c11-py2.6.egg</div><div class="line"></div><div class="line">./setuptools-0.6c11-py2.6.egg</div></pre></td></tr></table></figure>
<h2 id="2-安装Python-pip"><a href="#2-安装Python-pip" class="headerlink" title="2.安装Python-pip"></a>2.安装Python-pip</h2><blockquote>
<p>由于一些第三方库需要用pip来安装所以要把Python-pip安装上。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">wget --no-check-certificate https://pypi.python.org/packages/source/p/pip/pip-1.4.tar.gz</div><div class="line"></div><div class="line">tar -zxvf ./pip-1.4.tar.gz</div><div class="line"></div><div class="line">cd pip-1.4</div><div class="line"></div><div class="line">sudo python setup.py install</div></pre></td></tr></table></figure>
<h2 id="3-安装Python-Gevent"><a href="#3-安装Python-Gevent" class="headerlink" title="3.安装Python-Gevent"></a>3.安装Python-Gevent</h2><blockquote>
<p>为了提高性能Python-Gevent还是必须要安装的.</p>
</blockquote>
<p>由于gevent需要用到libevent和python-devel所以我们需要现在这个.<br>在CentOS下可以用yum install libevent python-devel来安装<br>如果你的ubuntu的话可以用 apt-get来安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">yum install libevent</div><div class="line">yum install python-devel</div><div class="line">pip install gevent</div></pre></td></tr></table></figure>
<h2 id="4-安装Python-M2Crypto模块"><a href="#4-安装Python-M2Crypto模块" class="headerlink" title="4.安装Python-M2Crypto模块"></a>4.安装Python-M2Crypto模块</h2><blockquote>
<p>M2Crypto是用于加密的第三库、由于众所周知的一些原因我们还是需要进行加密的。否则你的梯子可能不几天就被墙了。</p>
</blockquote>
<p>首先需要先安装M2Crypto的一些依赖库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">yum install openssl-devel</div><div class="line">yum install swig</div><div class="line">pip install M2Crypto</div></pre></td></tr></table></figure>
<h2 id="5-安装ShadowSocks-Python程序"><a href="#5-安装ShadowSocks-Python程序" class="headerlink" title="5.安装ShadowSocks-Python程序"></a>5.安装ShadowSocks-Python程序</h2><blockquote>
<p>ShadowSocks其实有很多版本可以选择的、这里我是选择了Python版本、当然你可以选择安装Shadowsocks-go、libev、libuv、nodejs、还有erlang版本。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install shadowsocks</div></pre></td></tr></table></figure>
<h2 id="6-创建config-json配置文件"><a href="#6-创建config-json配置文件" class="headerlink" title="6.创建config.json配置文件"></a>6.创建config.json配置文件</h2><blockquote>
<p>ShadowSocks的配置文件你可以随便找个目录自己创建即可.在不同的目录下创建不同端口的config.json文件,然后分别启动.就会生成多个账号</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir ShadowSocks</div><div class="line">cd ShadowSocks</div><div class="line">vim config.json</div></pre></td></tr></table></figure>
<p>config.json配置文件内容如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">&quot;server&quot;:&quot;my_server_ip&quot;,</div><div class="line">&quot;server_port&quot;:8388,</div><div class="line">&quot;local_port&quot;:1080,</div><div class="line">&quot;password&quot;:&quot;barfoo!&quot;,</div><div class="line">&quot;timeout&quot;:600,</div><div class="line">&quot;method&quot;:&quot;aes-256-cfb&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每一个字段的含义：</p>
<ul>
<li>server          服务器 IP (IPv4/IPv6)，注意这也将是服务端监听的 IP 地址</li>
<li>server_port     服务器端口</li>
<li>local_port      本地端端口</li>
<li>password        用来加密的密码</li>
<li>timeout         超时时间（秒）</li>
<li>method          加密方法，可选择 “bf-cfb”, “aes-256-cfb”, “des-cfb”, “rc4”, 等等。默认是一种不安全的加密，推荐用 “aes-256-cfb”</li>
</ul>
<h2 id="7-运行ShadowSocks程序"><a href="#7-运行ShadowSocks程序" class="headerlink" title="7.运行ShadowSocks程序"></a>7.运行ShadowSocks程序</h2><blockquote>
<p>在服务器上cd到config.json所在的目录。运行ssserver即可</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sserver</div></pre></td></tr></table></figure>
<p>一般来说我们都让其在后台一直运行的，所以用如下命令即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nohup ssserver &gt; log &amp;</div></pre></td></tr></table></figure>
<p>到此ShadowSocks-python服务端的所有安装设置都完成了下面我们需要用到客户端来操作。</p>
<h2 id="8-下载客户端软件"><a href="#8-下载客户端软件" class="headerlink" title="8.下载客户端软件"></a>8.下载客户端软件</h2><blockquote>
<p>这里不得不说下ShadowSocks做得如此之好、到底有多么的好、您能常见的系统都有客户端支持。 从Windows、Mac OS、Linux、Android、iOS、甚至支持OpenWRT。</p>
</blockquote>
<h3 id="Windows设置"><a href="#Windows设置" class="headerlink" title="Windows设置"></a>Windows设置</h3><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p><a href="https://github.com/shadowsocks/shadowsocks-windows/releases?ShadowsocksR-win-dotnet4.0-3.7.9.7z" target="_blank" rel="external">下载地址1</a><br><a href="https://shadowsocks.org/en/download/clients.html" target="_blank" rel="external">下载地址2</a><br><a href="https://pan.baidu.com/s/1bpvGzDH" target="_blank" rel="external">下载地址3</a></p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>去ShadowSocks官网下载ShadowSocks-gui客户端。解压之后运行exe程序,然后设置好我们前面在config.json里面设置的内容即可。<br>按照截图里进行填写</p>
<p><img src="/images/pics/shadowsocks.png" alt="配置"></p>
<h3 id="浏览器设置"><a href="#浏览器设置" class="headerlink" title="浏览器设置"></a>浏览器设置</h3><p>如果是Chrome请使用Proxy SwitchyShar插件、如果是Firefox请使用AutoProxy插件。下面以Chrome为例来说明。</p>
<p>在 Proxy SwitchyShar中新建立一个SockS5代理。</p>
<p>设置完成之后、就没有之后了。开始翻越吧少年。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/21/2016-11-21-CommandPattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hushiwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/wei.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Time渐行渐远">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/21/2016-11-21-CommandPattern/" itemprop="url">
                  设计模式之命令模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-21T09:43:00+08:00">
                2016-11-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/designpattern/" itemprop="url" rel="index">
                    <span itemprop="name">designpattern</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/11/21/2016-11-21-CommandPattern/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/21/2016-11-21-CommandPattern/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><ul>
<li>命令模式在于有命令</li>
<li>命令也许有很多个命令,因此需要有个命令模式去解决这个问题</li>
<li>既然是命令,那么肯定符合这么几个要求<ul>
<li>命令本身</li>
<li>命令的接收者</li>
</ul>
</li>
<li>命令模式怎么开始<ul>
<li>构造命令<ul>
<li>命令本身</li>
<li>命令的接收者</li>
</ul>
</li>
<li>执行命令</li>
</ul>
</li>
<li>我们只需要关心最上层模式,对底层命令的实现封装.</li>
</ul>
<h2 id="对命令模式做简单介绍"><a href="#对命令模式做简单介绍" class="headerlink" title="对命令模式做简单介绍"></a>对命令模式做简单介绍</h2><h3 id="场景-餐厅点餐"><a href="#场景-餐厅点餐" class="headerlink" title="场景:餐厅点餐"></a>场景:餐厅点餐</h3><h2 id="命令模式的运用场景"><a href="#命令模式的运用场景" class="headerlink" title="命令模式的运用场景"></a>命令模式的运用场景</h2><h2 id="命令模式能解决什么样的问题"><a href="#命令模式能解决什么样的问题" class="headerlink" title="命令模式能解决什么样的问题"></a>命令模式能解决什么样的问题</h2><h2 id="命令模式有什么问题"><a href="#命令模式有什么问题" class="headerlink" title="命令模式有什么问题"></a>命令模式有什么问题</h2><h2 id="如何实现运用命令模式"><a href="#如何实现运用命令模式" class="headerlink" title="如何实现运用命令模式"></a>如何实现运用命令模式</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/17/2016-11-17-SparkRDDOpe/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hushiwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/wei.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Time渐行渐远">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/17/2016-11-17-SparkRDDOpe/" itemprop="url">
                  Spark的RDD基础操作
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-17T17:23:00+08:00">
                2016-11-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spark/" itemprop="url" rel="index">
                    <span itemprop="name">spark</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/11/17/2016-11-17-SparkRDDOpe/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/17/2016-11-17-SparkRDDOpe/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简单算子"><a href="#简单算子" class="headerlink" title="简单算子"></a>简单算子</h1><ul>
<li>1.构造一些数据</li>
<li>2.用map算子进行一些操作</li>
<li>3.用mapPartitions算子进行操作</li>
<li>4.调用zipwithpartition算子标记分区</li>
<li>5.调用foreachPartiton进行输出</li>
<li>6.调用glom算子收集每个分区的数据</li>
<li>7.调用flodleft函数处理Array</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">    val conf = new SparkConf().setAppName(&quot;SimpleRDD&quot;).setMaster(&quot;local[*]&quot;)</div><div class="line">    val sc = new SparkContext(conf)</div><div class="line">    /**</div><div class="line">      * 1.构造一些数据</div><div class="line">      * 2.用map算子进行一些操作</div><div class="line">      * 3.用mapPartitions算子进行操作</div><div class="line">      * 4.调用zipwithpartition算子标记分区</div><div class="line">      * 5.调用foreachPartiton进行输出</div><div class="line">      * 6.调用glom算子收集每个分区的数据</div><div class="line">      * 7.调用flodleft函数处理Array</div><div class="line">      */</div><div class="line">    def printRDD(rdd:RDD[_])=&#123;</div><div class="line">      val str=rdd.collect().mkString(&quot; , &quot;)</div><div class="line">      println(str)</div><div class="line">    &#125;</div><div class="line">    val numberRDD=sc.parallelize(1 until 10,2)</div><div class="line">    println(&quot;查看原始的RDD中的每一个元素:&quot;)</div><div class="line">//    numberRDD.foreach(println)</div><div class="line">//    printRDD(numberRDD)</div><div class="line">    val numberRDD10=numberRDD.map(_*10)</div><div class="line">    printRDD(numberRDD10)</div><div class="line">    val numberRDDLess=numberRDD10.mapPartitions(iter=&gt; &#123;</div><div class="line">      val arr=new ArrayBuffer[Double]</div><div class="line">      while (iter.hasNext) &#123;</div><div class="line">        val value=iter.next().toDouble/10</div><div class="line">          arr+=value</div><div class="line">      &#125;</div><div class="line">      arr.iterator</div><div class="line">    &#125;)</div><div class="line">    printRDD(numberRDDLess)</div><div class="line"></div><div class="line">    // glom 是把每个分区里面的元素放到一个list里面</div><div class="line">    val partitions=numberRDDLess.glom()</div><div class="line">    println(&quot;构造数据的时候创建了 &quot;+numberRDDLess.partitions.size+&quot; 个分区&quot;)</div><div class="line">    println(&quot;目前经过glom操作后,还有: &quot;+partitions.count()+&quot; 个分区,只是每个分区的数据存到到一个list中去了&quot;)</div><div class="line">    partitions.foreach(arr=&gt;&#123;</div><div class="line">      println(&quot;分区数据:&quot;+arr.mkString(&quot; , &quot;))</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    val numbers=partitions.zipWithIndex()</div><div class="line">    numbers.foreach&#123;</div><div class="line">      case (arr,v)=&gt;</div><div class="line">        println(&quot;第 &quot;+ v+&quot;个分区数据: &quot;+arr.mkString(&quot; , &quot;))</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    partitions.foreach(arr=&gt;&#123;</div><div class="line">      println(&quot;分区内容: &quot;+</div><div class="line">      arr.foldLeft(&quot;&quot;)((x,y)=&gt;x+&quot; &quot;+y))</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<h1 id="Spark懒加载实践"><a href="#Spark懒加载实践" class="headerlink" title="Spark懒加载实践"></a>Spark懒加载实践</h1><blockquote>
<p>通过例子说明,spark的确是当执行了一个action算子,才会生成一个job.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">  val conf = new SparkConf().setAppName(&quot;Computations&quot;).setMaster(&quot;local[*]&quot;)</div><div class="line">  val sc = new SparkContext(conf)</div><div class="line"></div><div class="line">  // 构造一个数据集</div><div class="line">  val numbers = sc.parallelize(1 to 10, 4)</div><div class="line">  val bigger = numbers.map(n =&gt; n * 100)</div><div class="line">  val biggerStill = bigger.map(n =&gt; n + 1)</div><div class="line"></div><div class="line">  println(&quot;调用 toDebugString 算子去查看经过几次转换后,依赖关系是什么样:&quot;)</div><div class="line">  println(biggerStill.toDebugString)</div><div class="line"></div><div class="line">  //    进行一次reduce操作</div><div class="line">  val s = biggerStill.reduce(_ + _)</div><div class="line"></div><div class="line">  println(&quot;sum = &quot; + s)</div><div class="line"></div><div class="line">  println(&quot;numbersRDD的id = &quot; + numbers.id)</div><div class="line">  println(&quot;biggerRDD的id = &quot; + bigger.id)</div><div class="line">  println(&quot;biggerStillRDD的id = &quot; + biggerStill.id)</div><div class="line">  println(&quot;查看biggerStill RDD 依赖继承关系: &quot;)</div><div class="line">  showDependency(biggerStill)</div><div class="line"></div><div class="line">  val moreNumbers = bigger ++ biggerStill</div><div class="line">  println(&quot;moreNumbers的依赖继承关系: &quot;)</div><div class="line">  println(moreNumbers.toDebugString)</div><div class="line">  println(&quot;moreNumbers: id=&quot; + moreNumbers.id)</div><div class="line">  showDependency(moreNumbers)</div><div class="line"></div><div class="line">  moreNumbers.cache()</div><div class="line">  // cache操作可能会丢失数据,而且并没有发生依赖的变化</div><div class="line">  println(&quot;cached moreNumbers的依赖继承关系(并没有变化): &quot;)</div><div class="line">  println(moreNumbers.toDebugString)</div><div class="line">  println(&quot;执行 cache 操作后,moreNumbers的依赖继承关系: &quot;)</div><div class="line"></div><div class="line">  showDependency(moreNumbers)</div><div class="line"></div><div class="line">  println(&quot;检查一下moreNumbers有没有设置检查点? : &quot; + moreNumbers.isCheckpointed)</div><div class="line">  sc.setCheckpointDir(&quot;/tmp/sparkcps&quot;)</div><div class="line">  moreNumbers.checkpoint()</div><div class="line">  println(&quot;现在执行了checkpoint 检查一下moreNumbers有没有设置检查点? : &quot; + moreNumbers.isCheckpointed)</div><div class="line">  moreNumbers.count()</div><div class="line">  println(&quot;现在执行了一个count操作 检查一下moreNumbers有没有设置检查点? : &quot; + moreNumbers.isCheckpointed)</div><div class="line">  println(moreNumbers.toDebugString)</div><div class="line">  println(&quot;做了以上操作后,moreNumbers的依赖继承关系: &quot;)</div><div class="line">  showDependency(moreNumbers)</div><div class="line"></div><div class="line">  println(&quot;这里不应该抛异常...&quot;)</div><div class="line">  println(&quot;因为spark是懒加载,只有遇到action算子的时候,才会开始生成job开始调度计算....&quot;)</div><div class="line">  val thisWillBlowUp = numbers map &#123;</div><div class="line">    case (7) =&gt; &#123;</div><div class="line">      throw new Exception</div><div class="line">    &#125;</div><div class="line">    case (n) =&gt; n</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  println(&quot;异常应该在这里抛出来...&quot;)</div><div class="line">  try &#123;</div><div class="line">    println(thisWillBlowUp.count())</div><div class="line">  &#125; catch &#123;</div><div class="line">    case (e: Exception) =&gt; println(&quot;Nice,果真在这里抛异常了...&quot;)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">// 利用递归函数来输出rdd的依赖继承关系</div><div class="line">def showDependency[T](rdd: RDD[T]): Unit = &#123;</div><div class="line">  showDependency(rdd, 0)</div><div class="line">&#125;</div><div class="line"></div><div class="line">private def showDependency[T](rdd: RDD[T], length: Int): Unit = &#123;</div><div class="line">  println(&quot;&quot;.padTo(length, &apos; &apos;) + &quot;RDD id= &quot; + rdd.id)</div><div class="line">  rdd.dependencies.foreach(dep =&gt; &#123;</div><div class="line">    showDependency(dep.rdd, length + 1)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>#</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/16/2016-11-16-MakeData/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hushiwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/wei.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Time渐行渐远">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/16/2016-11-16-MakeData/" itemprop="url">
                  大数据学习时候,造数据的常用方式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-16T10:51:00+08:00">
                2016-11-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/bigdata/" itemprop="url" rel="index">
                    <span itemprop="name">bigdata</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/11/16/2016-11-16-MakeData/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/16/2016-11-16-MakeData/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一些提供数据的网站"><a href="#一些提供数据的网站" class="headerlink" title="一些提供数据的网站"></a>一些提供数据的网站</h1><ul>
<li><a href="http://grouplens.org/datasets/" target="_blank" rel="external">Grouplens</a></li>
<li><a href="https://datahub.io/" target="_blank" rel="external">datahub</a></li>
<li><a href="http://www-etud.iro.umontreal.ca/~bergstrj/audioscrobbler_data.html" target="_blank" rel="external">profiledata_06-May-2005.tar.gz </a></li>
<li><a href="http://archive.ics.uci.edu/ml/" target="_blank" rel="external">UCI Machine Learning Repository</a></li>
<li><a href="http://www.sogou.com/labs/resource/list_pingce.php" target="_blank" rel="external">搜狗实验室</a></li>
<li><a href="https://www.quora.com/What-kinds-of-large-datasets-open-to-the-public-do-you-analyze-the-mostl" target="_blank" rel="external">large datasets list from quora</a></li>
<li><a href="http://www.kdnuggets.com/datasets/index.html" target="_blank" rel="external">kdnuggets</a></li>
<li><a href="https://aws.amazon.com/cn/public-data-sets/" target="_blank" rel="external">AmazonPublicData</a></li>
</ul>
<h1 id="用log4j造假日志数据"><a href="#用log4j造假日志数据" class="headerlink" title="用log4j造假日志数据"></a>用log4j造假日志数据</h1><p>代码我就不贴了,用log4j来造假的日志数据是我们经常用到的方法.借助于随机数,以及一些数据结构,我们可以很方便的造一些文本数据出来.供我们测试程序.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/16/2016-11-16-SparkFunctions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hushiwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/wei.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Time渐行渐远">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/16/2016-11-16-SparkFunctions/" itemprop="url">
                  Spark算子详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-16T09:51:00+08:00">
                2016-11-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spark/" itemprop="url" rel="index">
                    <span itemprop="name">spark</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/11/16/2016-11-16-SparkFunctions/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/16/2016-11-16-SparkFunctions/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="aggregate"><a href="#aggregate" class="headerlink" title="aggregate"></a>aggregate</h3><blockquote>
<p>def aggregate<a href="zeroValue: U" target="_blank" rel="external">U: ClassTag</a>(seqOp: (U, T) =&gt; U, combOp: (U, U) =&gt; U): U</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">    val conf=new SparkConf().setAppName(&quot;aggregate&quot;).setMaster(&quot;local[*]&quot;)</div><div class="line">    val sc=new SparkContext(conf)</div><div class="line">    val z=sc.parallelize(List(1,2,3,4,5,6),2)</div><div class="line">//打印每个分区里面的内容</div><div class="line">    z.glom().foreach(arr=&gt;&#123;</div><div class="line">      println(arr.foldLeft(&quot; &quot;)((x,y)=&gt;x+y))</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    // This example returns 16 since the initial value is 5 设置处理值5,注意这个初始值会出现在每个每个分区中作为初始值。就像下面的，每个分区都有5</div><div class="line">    // reduce of partition 0 will be max(5, 1, 2, 3) = 5</div><div class="line">    // reduce of partition 1 will be max(5, 4, 5, 6) = 6</div><div class="line">    // final reduce across partitions will be 5 + 5 + 6 = 16  进行最后一个方法的时候，还会加上初始值5</div><div class="line">    // note the final reduce include the initial value 最后得出的才是结果</div><div class="line">    // 因此得出结论，aggregate聚合算子的三个参数分别是。第一个是设置初始值。第二个Sep函数是对每个分区中的内容进行操作的函数。第三个Combi函数是聚合每个分区的函数</div><div class="line">    val result=z.aggregate(0)(math.max(_,_),_+_)</div><div class="line">    val result1=z.aggregate(5)(math.max(_,_),_+_)</div><div class="line">    println(&quot;result: &quot;+result)</div><div class="line">    println(&quot;result1: &quot;+result1)</div><div class="line">//    456</div><div class="line">//    123</div><div class="line">//    result: 9</div><div class="line">//    result1: 16</div><div class="line">    sc.stop()</div></pre></td></tr></table></figure>
<h3 id="cartesian"><a href="#cartesian" class="headerlink" title="cartesian"></a>cartesian</h3><blockquote>
<p> def cartesian<a href="other: RDD[U]" target="_blank" rel="external">U: ClassTag</a>: RDD[(T, U)]</p>
</blockquote>
<p>将其中一个分区里面的元素跟另一个分区的每一个元素进行笛卡尔积计算.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">val conf = new SparkConf().setAppName(&quot;Cartesian&quot;).setMaster(&quot;local[*]&quot;)</div><div class="line">val sc = new SparkContext(conf)</div><div class="line">val data1 = Array[(String, Int)]((&quot;A1&quot;, 1), (&quot;A2&quot;, 2),</div><div class="line">  (&quot;B1&quot;, 3), (&quot;B2&quot;, 4),</div><div class="line">  (&quot;C1&quot;, 5), (&quot;C1&quot;, 6))</div><div class="line"></div><div class="line">val data2 = Array[(String, Int)]((&quot;A1&quot;, 7), (&quot;A2&quot;, 8),</div><div class="line">  (&quot;B1&quot;, 9), (&quot;C1&quot;, 0))</div><div class="line">val pairs1 = sc.parallelize(data1, 3)</div><div class="line">val pairs2 = sc.parallelize(data2, 2)</div><div class="line"></div><div class="line">val resultRDD = pairs1.cartesian(pairs2)</div><div class="line"></div><div class="line">resultRDD.foreach(println)</div></pre></td></tr></table></figure>
<h3 id="collectAsMap"><a href="#collectAsMap" class="headerlink" title="collectAsMap"></a>collectAsMap</h3><blockquote>
<p>把元组作为元素的List转化成Map,主要是调用可变的HashMap</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">    val conf = new SparkConf().setAppName(&quot;CollectAsMap&quot;).setMaster(&quot;local[*]&quot;)</div><div class="line">    val sc = new SparkContext(conf)</div><div class="line">    val data = Array[(String, Int)]((&quot;A&quot;, 1), (&quot;B&quot;, 2),</div><div class="line">      (&quot;B&quot;, 3), (&quot;C&quot;, 4),</div><div class="line">      (&quot;C&quot;, 5), (&quot;C&quot;, 6))</div><div class="line"></div><div class="line">    // as same as &quot;val pairs = sc.parallelize(data, 3)&quot; 底层源码,也还是调用的parallelize</div><div class="line">    val pairs = sc.makeRDD(data, 3)</div><div class="line">    val result = pairs.collectAsMap</div><div class="line"></div><div class="line">    // output Map(A -&gt; 1, C -&gt; 6, B -&gt; 3)</div><div class="line">    print(result)</div><div class="line"></div><div class="line">//    list2map(data)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  def list2map(list: Array[(String, Int)]): mutable.HashMap[String, Int] = &#123;</div><div class="line">    val map = new mutable.HashMap[String, Int]</div><div class="line">    list.foreach(value=&gt; map.put(value._1,value._2))</div><div class="line">    map</div></pre></td></tr></table></figure>
<h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><blockquote>
<p>def flatMap<a href="f: T =&gt; TraversableOnce[U]" target="_blank" rel="external">U: ClassTag</a>: RDD[U]</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">val conf = new SparkConf().setAppName(&quot;FlatMap&quot;).setMaster(&quot;local[*]&quot;)</div><div class="line">val sc = new SparkContext(conf)</div><div class="line">val array=Array[String](&quot;Hello&quot;,&quot;World&quot;,&quot;hadoop&quot;)</div><div class="line">val strRDD=sc.parallelize(array)</div><div class="line">val str2arrayRDD=strRDD.flatMap(x=&gt;x.toCharArray)</div><div class="line">str2arrayRDD.foreach(println)</div></pre></td></tr></table></figure>
<h3 id="GroupByKey"><a href="#GroupByKey" class="headerlink" title="GroupByKey"></a>GroupByKey</h3><blockquote>
<p>def groupByKey(numPartitions: Int): RDD[(K, Iterable[V])]</p>
</blockquote>
<p>会造成shuffle的算子，根据key分组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">    var numMappers = 10</div><div class="line">    var numPartition=10</div><div class="line">    var numKVPairs = 100</div><div class="line">    var valSize = 100</div><div class="line">    var numReducers = 3</div><div class="line"></div><div class="line">    val conf = new SparkConf().setAppName(&quot;GroupBy Test&quot;).setMaster(&quot;local[*]&quot;)</div><div class="line">    val sc = new SparkContext(conf)</div><div class="line">//  造一些测试数据</div><div class="line">//    0到10，10次循环，10个分区</div><div class="line">//    每次循环里面造100个键值对</div><div class="line">    val pairs1 = sc.parallelize(0 until numMappers, numPartition).flatMap &#123; p =&gt;</div><div class="line">      val ranGen = new Random</div><div class="line">      var arr1 = new Array[(Int, Array[Byte])](numKVPairs)</div><div class="line">      for (i &lt;- 0 until numKVPairs) &#123;</div><div class="line">        val byteArr = new Array[Byte](valSize)</div><div class="line">        ranGen.nextBytes(byteArr)</div><div class="line">        arr1(i) = (ranGen.nextInt(10), byteArr)</div><div class="line">      &#125;</div><div class="line">      arr1</div><div class="line">    &#125;.cache</div><div class="line">    // cache一下</div><div class="line">//    因此一共是10X100=1000个</div><div class="line">    println(&quot;pairs1.count: &quot;+pairs1.count)</div><div class="line"></div><div class="line">    val result = pairs1.groupByKey(numReducers)</div><div class="line">//    造数据的时候，key的取值是10以内，所以分组肯定是10个，和结果一样</div><div class="line">    println(&quot;result.count: &quot;+result.count)</div><div class="line">    println(result.toDebugString)</div><div class="line"></div><div class="line">    sc.stop()</div></pre></td></tr></table></figure>
<h3 id="groupBy"><a href="#groupBy" class="headerlink" title="groupBy"></a>groupBy</h3><blockquote>
<p>def groupBy<a href="f: T =&gt; K" target="_blank" rel="external">K</a>(implicit kt: ClassTag[K]): RDD[(K, Iterable[T])]</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">val conf = new SparkConf().setAppName(&quot;GroupByAction&quot;).setMaster(&quot;local[*]&quot;)</div><div class="line">val sc = new SparkContext(conf)</div><div class="line">val data = Array[(String, Int)]((&quot;A1&quot;, 1), (&quot;A2&quot;, 2),</div><div class="line">  (&quot;B1&quot;, 6), (&quot;A2&quot;, 4),</div><div class="line">  (&quot;B1&quot;, 3), (&quot;B1&quot;, 5))</div><div class="line"></div><div class="line">val pairs = sc.parallelize(data, 3)</div><div class="line">pairs.foreach(println)</div><div class="line">val result1 = pairs.groupBy(K =&gt; K._1)</div><div class="line">// 设置分区数量</div><div class="line">val result2 = pairs.groupBy((K: (String, Int)) =&gt; K._1,1)</div><div class="line">// 定义分区的类</div><div class="line">val result3 = pairs.groupBy((K: (String, Int)) =&gt; K._1, new RangePartitioner(3, pairs))</div><div class="line"></div><div class="line">result1.foreach(println)</div><div class="line">result2.foreach(println)</div><div class="line">result3.foreach(println)</div></pre></td></tr></table></figure>
<h3 id="groupWith"><a href="#groupWith" class="headerlink" title="groupWith"></a>groupWith</h3><blockquote>
<p> def groupWith<a href="other: RDD[(K, W" target="_blank" rel="external">W</a>]): RDD[(K, (Iterable[V], Iterable[W]))]</p>
</blockquote>
<p>Alias for cogroup</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">val conf = new SparkConf().setAppName(&quot;GroupWith&quot;).setMaster(&quot;local[*]&quot;)</div><div class="line">val sc = new SparkContext(conf)</div><div class="line"></div><div class="line">val data1 = Array[(String, Int)]((&quot;A1&quot;, 1), (&quot;A2&quot;, 2),</div><div class="line">  (&quot;B1&quot;, 3), (&quot;B2&quot;, 4),</div><div class="line">  (&quot;C1&quot;, 5), (&quot;C1&quot;, 6)</div><div class="line">)</div><div class="line"></div><div class="line">val data2 = Array[(String, Int)]((&quot;A1&quot;, 7), (&quot;A2&quot;, 8),</div><div class="line">  (&quot;B1&quot;, 9), (&quot;C1&quot;, 0)</div><div class="line">)</div><div class="line">val pairs1 = sc.parallelize(data1, 3)</div><div class="line">val pairs2 = sc.parallelize(data2, 2)</div><div class="line"></div><div class="line">val result = pairs1.groupWith(pairs2)</div><div class="line">result.foreach(println)</div></pre></td></tr></table></figure>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><blockquote>
<p>def join<a href="other: RDD[(K, W" target="_blank" rel="external">W</a>], partitioner: Partitioner): RDD[(K, (V, W))]</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">val conf = new SparkConf().setAppName(&quot;JoinAction&quot;).setMaster(&quot;local[*]&quot;)</div><div class="line">val sc = new SparkContext(conf)</div><div class="line"></div><div class="line">val data1 = Array[(String, Int)]((&quot;A1&quot;, 1), (&quot;A2&quot;, 2),</div><div class="line">  (&quot;B1&quot;, 3), (&quot;B2&quot;, 4),</div><div class="line">  (&quot;C1&quot;, 5), (&quot;C1&quot;, 6)</div><div class="line">)</div><div class="line"></div><div class="line">val data2 = Array[(String, Int)]((&quot;A1&quot;, 7), (&quot;A2&quot;, 8),</div><div class="line">  (&quot;B1&quot;, 9), (&quot;C1&quot;, 0)</div><div class="line">)</div><div class="line">val pairs1 = sc.parallelize(data1, 3)</div><div class="line">val pairs2 = sc.parallelize(data2, 2)</div><div class="line"></div><div class="line"></div><div class="line">val result = pairs1.join(pairs2)</div><div class="line">result.foreach(println)</div></pre></td></tr></table></figure>
<h3 id="lookup"><a href="#lookup" class="headerlink" title="lookup"></a>lookup</h3><blockquote>
<p>def lookup(key: K): Seq[V]</p>
</blockquote>
<p>(针对pair类型的RDD)根据这个K值,找出相应的value值，放入到List里面返回出来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">val conf = new SparkConf().setAppName(&quot;LookUp&quot;).setMaster(&quot;local[*]&quot;)</div><div class="line">val sc = new SparkContext(conf)</div><div class="line">val data = Array[(String, Int)]((&quot;A&quot;, 1), (&quot;B&quot;, 2),</div><div class="line">  (&quot;B&quot;, 3), (&quot;C&quot;, 4),</div><div class="line">  (&quot;C&quot;, 5), (&quot;C&quot;, 6))</div><div class="line"></div><div class="line">val pairs = sc.parallelize(data, 3)</div><div class="line"></div><div class="line">val finalRDD = pairs.lookup(&quot;B&quot;)</div><div class="line"></div><div class="line">finalRDD.foreach(println)</div></pre></td></tr></table></figure>
<h3 id="mapPartitions"><a href="#mapPartitions" class="headerlink" title="mapPartitions"></a>mapPartitions</h3><blockquote>
<p>def mapPartitions<a href="f: Iterator[T] =&gt; Iterator[U],preservesPartitioning: Boolean = false" target="_blank" rel="external">U: ClassTag</a>: RDD[U]</p>
</blockquote>
<p>是针对这个RDD的每个partition进行操作的，比如在进行数据库链接的时候，使用这个算子，可以减少</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">val conf = new SparkConf().setAppName(&quot;MapPartitionsRDD&quot;).setMaster(&quot;local[*]&quot;)</div><div class="line">    val sc = new SparkContext(conf)</div><div class="line">    val data = Array[(String, Int)]((&quot;A1&quot;, 1), (&quot;A2&quot;, 2),</div><div class="line">      (&quot;B1&quot;, 1), (&quot;B2&quot;, 4),</div><div class="line">      (&quot;C1&quot;, 3), (&quot;C2&quot;, 4)</div><div class="line">    )</div><div class="line">    val pairs = sc.parallelize(data, 3)</div><div class="line"></div><div class="line">    val finalRDD = pairs.mapPartitions(iter =&gt; iter.filter(_._2 &gt;= 2))</div><div class="line"></div><div class="line">    finalRDD.foreachPartition(iter =&gt; &#123;</div><div class="line">      while (iter.hasNext) &#123;</div><div class="line">        val next = iter.next()</div><div class="line">        println(next._1 + &quot; --- &quot; + next._2)</div><div class="line"></div><div class="line">      &#125;</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<h3 id="mapValues"><a href="#mapValues" class="headerlink" title="mapValues"></a>mapValues</h3><blockquote>
<p>def mapValues<a href="f: V =&gt; U" target="_blank" rel="external">U</a>: RDD[(K, U)]</p>
</blockquote>
<p>不改变RDD原有的分区，也不改变Key值，修改value的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">    val conf = new SparkConf().setAppName(&quot;mapValues&quot;).setMaster(&quot;local[*]&quot;)</div><div class="line">    val sc = new SparkContext(conf)</div><div class="line">    val data1 = Array[(String, Int)]((&quot;K&quot;, 1), (&quot;T&quot;, 2),</div><div class="line">      (&quot;T&quot;, 3), (&quot;W&quot;, 4),</div><div class="line">      (&quot;W&quot;, 5), (&quot;W&quot;, 6)</div><div class="line">    )</div><div class="line">    val pairs = sc.parallelize(data1, 3)</div><div class="line">    val result = pairs.mapValues(V =&gt; 10 * V)</div><div class="line">//    val result=pairs.map &#123; case (k, v) =&gt; (k, v * 10) &#125;</div><div class="line">    result.foreach(println)</div></pre></td></tr></table></figure>
<h3 id="partitionBy"><a href="#partitionBy" class="headerlink" title="partitionBy"></a>partitionBy</h3><blockquote>
<p>def partitionBy(partitioner: Partitioner): RDD[(K, V)]</p>
</blockquote>
<p>用指定的分区类来处理RDD</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">val conf = new SparkConf().setAppName(&quot;partitionBy&quot;).setMaster(&quot;local[*]&quot;)</div><div class="line">val sc = new SparkContext(conf)</div><div class="line">val data1 = Array[(String, Int)]((&quot;K&quot;, 1), (&quot;T&quot;, 2),</div><div class="line">  (&quot;T&quot;, 3), (&quot;W&quot;, 4),</div><div class="line">  (&quot;W&quot;, 5), (&quot;W&quot;, 6)</div><div class="line">)</div><div class="line">val pairs = sc.parallelize(data1, 3)</div><div class="line">val result = pairs.partitionBy(new RangePartitioner(2, pairs, true))</div><div class="line">//val result = pairs.partitionBy(new HashPartitioner(2))</div><div class="line">result.foreach(println)</div></pre></td></tr></table></figure>
<h3 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h3><blockquote>
<p>def pipe(command: String): RDD[String]</p>
</blockquote>
<p>command命令在windows上测不了额</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">val conf = new SparkConf().setAppName(&quot;Pip&quot;).setMaster(&quot;local[*]&quot;)</div><div class="line">val sc = new SparkContext(conf)</div><div class="line">val data1 = Array[(String, Int)]((&quot;K1&quot;, 1), (&quot;K2&quot;, 2),</div><div class="line">  (&quot;U1&quot;, 3), (&quot;U2&quot;, 4),</div><div class="line">  (&quot;W1&quot;, 3), (&quot;W2&quot;, 4)</div><div class="line">)</div><div class="line">val pairs = sc.parallelize(data1, 3)</div><div class="line">val finalRDD = pairs.pipe(&quot;grep 2&quot;)</div><div class="line">finalRDD.foreach(println)</div></pre></td></tr></table></figure>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><blockquote>
<p>def reduce(f: (T, T) =&gt; T): T</p>
</blockquote>
<p>迭代处理之前的元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">val conf = new SparkConf().setAppName(&quot;reduce&quot;).setMaster(&quot;local[*]&quot;)</div><div class="line">val sc = new SparkContext(conf)</div><div class="line">val data1 = Array[(String, Int)]((&quot;K1&quot;, 1), (&quot;K2&quot;, 2),</div><div class="line">  (&quot;U1&quot;, 3), (&quot;U2&quot;, 4),</div><div class="line">  (&quot;W1&quot;, 3), (&quot;W2&quot;, 4)</div><div class="line">)</div><div class="line">val pairs = sc.parallelize(data1, 3)</div><div class="line">val result = pairs.reduce((A, B) =&gt; (A._1 + &quot;#&quot; + B._1, A._2 + B._2))</div><div class="line">//val result = pairs.fold((&quot;K0&quot;,10))((A, B) =&gt; (A._1 + &quot;#&quot; + B._1, A._2 + B._2))</div><div class="line"></div><div class="line">println(result)</div></pre></td></tr></table></figure>
<h3 id="reduceByKey"><a href="#reduceByKey" class="headerlink" title="reduceByKey"></a>reduceByKey</h3><blockquote>
<p>reduceByKey(func: (V, V) =&gt; V): RDD[(K, V)]</p>
</blockquote>
<p>有好几个重载方法,可以指定分区数,分区的类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">val conf = new SparkConf().setAppName(&quot;reduceByKey&quot;).setMaster(&quot;local[*]&quot;)</div><div class="line">val sc = new SparkContext(conf)</div><div class="line">val data1 = Array[(String, Int)]((&quot;K&quot;, 1), (&quot;U&quot;, 2),</div><div class="line">  (&quot;U&quot;, 3), (&quot;W&quot;, 4),</div><div class="line">  (&quot;W&quot;, 5), (&quot;W&quot;, 6)</div><div class="line">)</div><div class="line">val pairs = sc.parallelize(data1, 3)</div><div class="line">val result = pairs.reduceByKey(_ + _)</div><div class="line">result.foreach(println)</div></pre></td></tr></table></figure>
<h3 id="sortByKey"><a href="#sortByKey" class="headerlink" title="sortByKey"></a>sortByKey</h3><blockquote>
<p> def sortByKey(ascending: Boolean = true, numPartitions: Int = self.partitions.length): RDD[(K, V)]</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">val conf = new SparkConf().setAppName(&quot;sortByKey&quot;).setMaster(&quot;local[*]&quot;)</div><div class="line">val sc = new SparkContext(conf)</div><div class="line"></div><div class="line">val data1 = Array[(String, Int)]((&quot;K1&quot;, 1), (&quot;K2&quot;, 2),</div><div class="line">  (&quot;U1&quot;, 3), (&quot;U2&quot;, 4),</div><div class="line">  (&quot;W1&quot;, 5), (&quot;W1&quot;, 6)</div><div class="line">)</div><div class="line">val pairs1 = sc.parallelize(data1, 3)</div><div class="line"></div><div class="line">//val result = pairs.fold((&quot;K0&quot;,10))((A, B) =&gt; (A._1 + &quot;#&quot; + B._1, A._2 + B._2))</div><div class="line"></div><div class="line">val result = pairs1.sortByKey()</div><div class="line">result.foreach(println)</div></pre></td></tr></table></figure>
<h3 id="take"><a href="#take" class="headerlink" title="take"></a>take</h3><blockquote>
<p>def take(num: Int): Array[T]</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">val conf = new SparkConf().setAppName(&quot;take&quot;).setMaster(&quot;local[*]&quot;)</div><div class="line">val sc = new SparkContext(conf)</div><div class="line">val data1 = Array[(String, Int)]((&quot;K1&quot;, 1), (&quot;K2&quot;, 2),</div><div class="line">  (&quot;U1&quot;, 3), (&quot;U2&quot;, 4),</div><div class="line">  (&quot;W1&quot;, 3), (&quot;W2&quot;, 4)</div><div class="line">)</div><div class="line">val pairs = sc.parallelize(data1, 3)</div><div class="line">val result = pairs.take(5)</div><div class="line">result.foreach(println)</div></pre></td></tr></table></figure>
<h3 id="union"><a href="#union" class="headerlink" title="union"></a>union</h3><blockquote>
<p>def union(other: RDD[T]): RDD[T]</p>
</blockquote>
<p>union聚合算子,不会去重,如果需要去重,调用distinct算子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">val conf = new SparkConf().setAppName(&quot;union&quot;).setMaster(&quot;local[*]&quot;)</div><div class="line">val sc = new SparkContext(conf)</div><div class="line"></div><div class="line">val data1 = Array[(String, Int)]((&quot;K1&quot;, 1), (&quot;K2&quot;, 2),</div><div class="line">  (&quot;U1&quot;, 3), (&quot;U2&quot;, 4),</div><div class="line">  (&quot;W1&quot;, 5), (&quot;W1&quot;, 6)</div><div class="line">)</div><div class="line"></div><div class="line">val data2 = Array[(String, Int)]((&quot;K1&quot;, 7), (&quot;K2&quot;, 8),</div><div class="line">  (&quot;U1&quot;, 9), (&quot;W1&quot;, 0)</div><div class="line">)</div><div class="line">val pairs1 = sc.parallelize(data1, 3)</div><div class="line">val pairs2 = sc.parallelize(data2, 2)</div><div class="line">val result = pairs1.union(pairs2)</div><div class="line">result.foreach(println)</div></pre></td></tr></table></figure>
<h3 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h3><blockquote>
<p>def checkpoint(): Unit</p>
</blockquote>
<p>设置了checkpoint后,写下来的数据,不会因为应用的停止而删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">var numMappers = 10</div><div class="line">var numPartition = 10</div><div class="line">var numKVPairs = 100</div><div class="line">var valSize = 100</div><div class="line">var numReducers = 3</div><div class="line"></div><div class="line">val conf = new SparkConf().setAppName(&quot;Checkpoint&quot;).setMaster(&quot;local[*]&quot;)</div><div class="line">val sc = new SparkContext(conf)</div><div class="line">sc.setCheckpointDir(&quot;D:\\data\\checkpoint&quot;)</div><div class="line">//  造一些测试数据</div><div class="line">//    0到10，10次循环，10个分区</div><div class="line">//    每次循环里面造100个键值对</div><div class="line">val pairs1 = sc.parallelize(0 until numMappers, numPartition).flatMap &#123; p =&gt;</div><div class="line">  val ranGen = new Random</div><div class="line">  var arr1 = new Array[(Int, Array[Byte])](numKVPairs)</div><div class="line">  for (i &lt;- 0 until numKVPairs) &#123;</div><div class="line">    val byteArr = new Array[Byte](valSize)</div><div class="line">    ranGen.nextBytes(byteArr)</div><div class="line">    arr1(i) = (ranGen.nextInt(10), byteArr)</div><div class="line">  &#125;</div><div class="line">  arr1</div><div class="line">&#125;.cache</div><div class="line">// cache一下</div><div class="line">//    因此一共是10X100=1000个</div><div class="line">println(&quot;pairs1.count: &quot; + pairs1.count)</div><div class="line"></div><div class="line">val result = pairs1.groupByKey(numReducers)</div><div class="line">result.checkpoint</div><div class="line"></div><div class="line">//    造数据的时候，key的取值是10以内，所以分组肯定是10个，和结果一样</div><div class="line">println(&quot;result.count: &quot; + result.count)</div><div class="line">println(result.toDebugString)</div><div class="line"></div><div class="line">sc.stop()</div></pre></td></tr></table></figure>
<h1 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h1><blockquote>
<p>def zip<a href="other: RDD[U]" target="_blank" rel="external">U: ClassTag</a>: RDD[(T, U)]</p>
</blockquote>
<p>注意: zip算子默认是认为这两个RDD的分区数和每个分区里面的个数是一样的，如果不能保证这两个条件，那么就会报错。如果不符合，那么可以用zipPartitions</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">    val conf = new SparkConf().setAppName(&quot;zip&quot;).setMaster(&quot;local[*]&quot;)</div><div class="line">    val sc = new SparkContext(conf)</div><div class="line">    //    构造数据集</div><div class="line">    val numberRDD = sc.parallelize(1 to 20, 4)</div><div class="line">    val numberRDDCopy = sc.parallelize(1 to 20, 4)</div><div class="line">    val letterRDD = sc.parallelize(&apos;a&apos; to &apos;z&apos;, 4)</div><div class="line"></div><div class="line">//    val result = numberRDD.zip(letterRDD)</div><div class="line">    val result = numberRDD.zip(numberRDDCopy)</div><div class="line">    try &#123;</div><div class="line">      result foreach &#123;</div><div class="line">        case (c, i) =&gt; println(i + &quot;:  &quot; + c)</div><div class="line">      &#125;</div><div class="line">    &#125; catch &#123;</div><div class="line">      case iae: IllegalArgumentException =&gt;</div><div class="line">        println(&quot;Exception caught IllegalArgumentException: &quot; + iae.getMessage)</div><div class="line">      case se: SparkException =&gt; &#123;</div><div class="line">        val t = se.getMessage</div><div class="line">        println(&quot;Exception caught SparkException: &quot; + se.getMessage)</div><div class="line">      &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="zipPartitions"><a href="#zipPartitions" class="headerlink" title="zipPartitions"></a>zipPartitions</h1><blockquote>
<p>def zipPartitions<a href="rdd2: RDD[B], preservesPartitioning: Boolean" target="_blank" rel="external">B: ClassTag, V: ClassTag</a>(f: (Iterator[T], Iterator[B]) =&gt; Iterator[V]): RDD[V]</p>
</blockquote>
<p>这个的灵活性就比zip算子高得多了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">    val conf = new SparkConf().setAppName(&quot;zipPartitions&quot;).setMaster(&quot;local[*]&quot;)</div><div class="line">    val sc = new SparkContext(conf)</div><div class="line">    //    构造数据集</div><div class="line">    val numberRDD = sc.parallelize(1 to 20, 4)</div><div class="line">    val letterRDD = sc.parallelize(&apos;a&apos; to &apos;z&apos;, 4)</div><div class="line">//    printRDD(numberRDD)</div><div class="line">//    printRDD(letterRDD)</div><div class="line">//    假设所有的partiton里面的元素个数是一样，当不一样的时候，我们需要处理一下咯</div><div class="line"></div><div class="line"></div><div class="line">    def func(numIter: Iterator[Int], lettIter: Iterator[Char]): Iterator[(Int, Char)] = &#123;</div><div class="line">      val arr = new ListBuffer[(Int, Char)]</div><div class="line">      while (numIter.hasNext || lettIter.hasNext) &#123;</div><div class="line"></div><div class="line">        if (numIter.hasNext &amp;&amp; lettIter.hasNext) &#123;</div><div class="line">          arr += ((numIter.next(), lettIter.next()))</div><div class="line">        &#125; else if (numIter.hasNext) &#123;</div><div class="line">          arr += ((numIter.next(), &apos; &apos;))</div><div class="line">        &#125; else if (lettIter.hasNext) &#123;</div><div class="line">          arr += ((0, lettIter.next()))</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      arr.iterator</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    val result=numberRDD.zipPartitions(letterRDD)(func)</div><div class="line">    result.foreach&#123;</div><div class="line">      case (k,v)=&gt;println(k+&quot; &quot;+v)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  def printRDD(rdd: RDD[_]) = &#123;</div><div class="line">    val nrdd = rdd.glom().zipWithIndex()</div><div class="line">    nrdd.foreach &#123;</div><div class="line">      case (k, v) =&gt;</div><div class="line">        println(&quot;第&quot; + v + &quot;个分区数据: &quot; + k.foldLeft(&quot;&quot;)((x, y) =&gt; x + &quot; &quot; + y))</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/14/2016-11-14-ScalaCollection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hushiwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/wei.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Time渐行渐远">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/14/2016-11-14-ScalaCollection/" itemprop="url">
                  Scala集合
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-14T13:37:00+08:00">
                2016-11-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/scala/" itemprop="url" rel="index">
                    <span itemprop="name">scala</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/11/14/2016-11-14-ScalaCollection/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/14/2016-11-14-ScalaCollection/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Scala集合"><a href="#Scala集合" class="headerlink" title="Scala集合"></a>Scala集合</h1><p>scala有一组丰富的集合库:List,Tuple,Option,Map</p>
<ul>
<li>集合可能是严格或懒惰</li>
<li>集合可以是可变的或不可变</li>
<li>不可变的集合可能包含可变项</li>
</ul>
<hr>
<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="List与Array区别"><a href="#List与Array区别" class="headerlink" title="List与Array区别"></a>List与Array区别</h2><ul>
<li>相同点<ul>
<li>所有元素都具有相同的类型</li>
</ul>
</li>
<li>不同点<ul>
<li>列表是不可变的,这意味着一个列表的元素可以不被分配来改变.</li>
<li>列表底层是一个链表,而数组是平坦的.</li>
</ul>
</li>
</ul>
<h2 id="定义Scala的List列表"><a href="#定义Scala的List列表" class="headerlink" title="定义Scala的List列表"></a>定义Scala的List列表</h2><p>1.有以下几种常用的方式来定义列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// List of Strings</div><div class="line">val fruit: List[String] = List(&quot;apples&quot;, &quot;oranges&quot;, &quot;pears&quot;)</div><div class="line"></div><div class="line">// List of Integers</div><div class="line">val nums: List[Int] = List(1, 2, 3, 4)</div><div class="line"></div><div class="line">// Empty List.</div><div class="line">val empty: List[Nothing] = List()</div><div class="line"></div><div class="line">// Two dimensional list</div><div class="line">val dim: List[List[Int]] =</div><div class="line">   List(</div><div class="line">      List(1, 0, 0),</div><div class="line">      List(0, 1, 0),</div><div class="line">      List(0, 0, 1)</div><div class="line">   )</div></pre></td></tr></table></figure>
<p>2.所有的列表可以使用两种基本的构建模块来定义,一个无尾Nil和::,但是这有明显的缺点.Nil也代表了空列表.上述的例子,也可以这样写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// List of Strings</div><div class="line">val fruit = &quot;apples&quot; :: (&quot;oranges&quot; :: (&quot;pears&quot; :: Nil))</div><div class="line"></div><div class="line">// List of Integers</div><div class="line">val nums = 1 :: (2 :: (3 :: (4 :: Nil)))</div><div class="line"></div><div class="line">// Empty List.</div><div class="line">val empty = Nil</div><div class="line"></div><div class="line">// Two dimensional list</div><div class="line">val dim = (1 :: (0 :: (0 :: Nil))) ::</div><div class="line">          (0 :: (1 :: (0 :: Nil))) ::</div><div class="line">          (0 :: (0 :: (1 :: Nil))) :: Nil</div></pre></td></tr></table></figure>
<p><strong>::符号就可以简单的替代了List()方法</strong></p>
<h2 id="列表的基本操作"><a href="#列表的基本操作" class="headerlink" title="列表的基本操作"></a>列表的基本操作</h2><blockquote>
<p>主要针对列表的头尾合是否为空来说</p>
</blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>head</td>
<td>此方法返回的列表中的第一个元素</td>
</tr>
<tr>
<td>tail</td>
<td>此方法返回一个由除了第一个元素外的所有元素的列表</td>
</tr>
<tr>
<td>isEmpty</td>
<td>如果列表为空，此方法返回true，否则为false</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">object Test &#123;</div><div class="line">   def main(args: Array[String]) &#123;</div><div class="line">      val fruit = &quot;apples&quot; :: (&quot;oranges&quot; :: (&quot;pears&quot; :: Nil))</div><div class="line">      val nums = Nil</div><div class="line"></div><div class="line">      println( &quot;Head of fruit : &quot; + fruit.head )</div><div class="line">      println( &quot;Tail of fruit : &quot; + fruit.tail )</div><div class="line">      println( &quot;Check if fruit is empty : &quot; + fruit.isEmpty )</div><div class="line">      println( &quot;Check if nums is empty : &quot; + nums.isEmpty )</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="串联列表"><a href="#串联列表" class="headerlink" title="串联列表"></a>串联列表</h2><blockquote>
<p>可以使用::运算符或者列表List.:::()方法来添加两个或多个列表</p>
</blockquote>
<p>eg:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">object Test &#123;</div><div class="line">   def main(args: Array[String]) &#123;</div><div class="line">      val fruit1 = &quot;apples&quot; :: (&quot;oranges&quot; :: (&quot;pears&quot; :: Nil))</div><div class="line">      val fruit2 = &quot;mangoes&quot; :: (&quot;banana&quot; :: Nil)</div><div class="line"></div><div class="line">      // use two or more lists with ::: operator</div><div class="line">      var fruit = fruit1 ::: fruit2</div><div class="line">      println( &quot;fruit1 ::: fruit2 : &quot; + fruit )</div><div class="line"></div><div class="line">      // use two lists with Set.:::() method</div><div class="line">      fruit = fruit1.:::(fruit2)</div><div class="line">      println( &quot;fruit1.:::(fruit2) : &quot; + fruit )</div><div class="line"></div><div class="line">      // pass two or more lists as arguments</div><div class="line">      fruit = List.concat(fruit1, fruit2)</div><div class="line">      println( &quot;List.concat(fruit1, fruit2) : &quot; + fruit  )</div><div class="line"></div><div class="line"></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>:: 元素之间进行连接,:::列表之间进行连接</p>
<h2 id="创建统一列表"><a href="#创建统一列表" class="headerlink" title="创建统一列表"></a>创建统一列表</h2><blockquote>
<p>可以使用List.fill()方法来创建,包括相同的元素如下的零个或更多个拷贝的列表</p>
</blockquote>
<p>eg</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">object Test &#123;</div><div class="line">   def main(args: Array[String]) &#123;</div><div class="line">      val fruit = List.fill(3)(&quot;apples&quot;) // Repeats apples three times.</div><div class="line">      println( &quot;fruit : &quot; + fruit  ) //fruit : List(apples, apples, apples)</div><div class="line"></div><div class="line">      val num = List.fill(10)(2)         // Repeats 2, 10 times.</div><div class="line">      println( &quot;num : &quot; + num  ) //num : List(2, 2, 2, 2, 2, 2, 2, 2, 2, 2)</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="反向列表顺序"><a href="#反向列表顺序" class="headerlink" title="反向列表顺序"></a>反向列表顺序</h2><blockquote>
<p>可以使用List.reverse方法来扭转列表中的所有元素</p>
</blockquote>
<p>eg</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">object Test &#123;</div><div class="line">   def main(args: Array[String]) &#123;</div><div class="line">      val fruit = &quot;apples&quot; :: (&quot;oranges&quot; :: (&quot;pears&quot; :: Nil))</div><div class="line">      println( &quot;Before reverse fruit : &quot; + fruit )</div><div class="line">      // Before reverse fruit : List(apples, oranges, pears)</div><div class="line">      println( &quot;After reverse fruit : &quot; + fruit.reverse )</div><div class="line">      // After reverse fruit : List(pears, oranges, apples)</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Scala列表常用方法"><a href="#Scala列表常用方法" class="headerlink" title="Scala列表常用方法"></a>Scala列表常用方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>def +(elem: A): List[A]</td>
<td>前置一个元素列表</td>
</tr>
<tr>
<td>def ::(x: A): List[A]</td>
<td>在这个列表的开头添加的元素。返回一个新的列表</td>
</tr>
<tr>
<td>def :::(prefix: List[A]): List[A]</td>
<td>增加了一个给定列表中该列表前面的元素。返回一个新的列表</td>
</tr>
<tr>
<td>def contains(elem: Any): Boolean</td>
<td>测试该列表中是否包含一个给定值作为元素。</td>
</tr>
<tr>
<td>def distinct: List[A]</td>
<td>建立从列表中没有任何重复的元素的新列表。</td>
</tr>
<tr>
<td>def drop(n: Int): List[A]</td>
<td>返回除了第n个的所有元素。</td>
</tr>
<tr>
<td>def endsWith<a href="that: Seq[B]" target="_blank" rel="external">B</a>: Boolean</td>
<td>测试列表是否使用给定序列结束。</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><ul>
<li>Set集合是不包含重复元素的集合</li>
<li>默认情况下,Scala中使用不可变的集.如果想使用可变集,必须明确导入sala.collection.mutable.Set类</li>
</ul>
<h2 id="声明Set集合类"><a href="#声明Set集合类" class="headerlink" title="声明Set集合类"></a>声明Set集合类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// Empty set of integer type</div><div class="line">var s : Set[Int] = Set()</div><div class="line"></div><div class="line">// Set of integer type</div><div class="line">var s : Set[Int] = Set(1,3,5,7)</div><div class="line">or</div><div class="line">var s = Set(1,3,5,7)</div></pre></td></tr></table></figure>
<h2 id="集合基本操作"><a href="#集合基本操作" class="headerlink" title="集合基本操作"></a>集合基本操作</h2><blockquote>
<p>集合所有操作可以体现在以下三个方法</p>
</blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>head</td>
<td>此方法返回集合的第一个元素。</td>
</tr>
</tbody>
</table>
<p>tail|该方法返回集合由除第一个以外的所有元素。|<br>|isEmpty|如果设置为空，此方法返回true，否则为false。|</p>
<p>eg:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">object Test &#123;</div><div class="line">   def main(args: Array[String]) &#123;</div><div class="line">      val fruit = Set(&quot;apples&quot;, &quot;oranges&quot;, &quot;pears&quot;)</div><div class="line">      val nums: Set[Int] = Set()</div><div class="line"></div><div class="line">      println( &quot;Head of fruit : &quot; + fruit.head )</div><div class="line">      println( &quot;Tail of fruit : &quot; + fruit.tail )</div><div class="line">      println( &quot;Check if fruit is empty : &quot; + fruit.isEmpty )</div><div class="line">      println( &quot;Check if nums is empty : &quot; + nums.isEmpty )</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="串联Set集合"><a href="#串联Set集合" class="headerlink" title="串联Set集合"></a>串联Set集合</h2><blockquote>
<p>可以使用++运算符或集。++()方法来连接两个或多个集，但同时增加了集它会删除重复的元素</p>
</blockquote>
<p>eg</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">object Test &#123;</div><div class="line">   def main(args: Array[String]) &#123;</div><div class="line">      val fruit1 = Set(&quot;apples&quot;, &quot;oranges&quot;, &quot;pears&quot;)</div><div class="line">      val fruit2 = Set(&quot;mangoes&quot;, &quot;banana&quot;)</div><div class="line"></div><div class="line">      // use two or more sets with ++ as operator</div><div class="line">      var fruit = fruit1 ++ fruit2</div><div class="line">      println( &quot;fruit1 ++ fruit2 : &quot; + fruit )</div><div class="line"></div><div class="line">      // use two sets with ++ as method</div><div class="line">      fruit = fruit1.++(fruit2)</div><div class="line">      println( &quot;fruit1.++(fruit2) : &quot; + fruit )</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ScalaSet集合常用方法"><a href="#ScalaSet集合常用方法" class="headerlink" title="ScalaSet集合常用方法"></a>ScalaSet集合常用方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>def +(elem: A): Set[A]</td>
<td>创建一组新的具有附加元件，除非该元件已经存在</td>
</tr>
<tr>
<td>def -(elem: A): Set[A]</td>
<td>创建一个新的从这个集合中删除一个给定的元素</td>
</tr>
<tr>
<td>def contains(elem: A): Boolean</td>
<td>如果elem包含在这个集合返回true，否则为false。</td>
</tr>
<tr>
<td>def take(n: Int): Set[A]</td>
<td>返回前n个元素</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><ul>
<li>在scala中的映射是键/值对的集合即是Map</li>
<li>任何值可以根据它的键进行检索</li>
<li>键是在映射中唯一的,但值不一定是唯一的</li>
<li>映射也被称为哈希表</li>
<li>有两种映射,不可变的以及可变的.不可变的意味着对象本身是不可变的.</li>
<li>默认情况下,scala中使用不可变的映射.要想使用可变集,必须明确导入scala.collection.mutable.Map类</li>
</ul>
<h2 id="声明Map类"><a href="#声明Map类" class="headerlink" title="声明Map类"></a>声明Map类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// Empty hash table whose keys are strings and values are integers:</div><div class="line">var A:Map[Char,Int] = Map()</div><div class="line"></div><div class="line">// A map with keys and values.</div><div class="line">val colors = Map(&quot;red&quot; -&gt; &quot;#FF0000&quot;, &quot;azure&quot; -&gt; &quot;#F0FFFF&quot;)</div></pre></td></tr></table></figure>
<h2 id="映射的基本操作"><a href="#映射的基本操作" class="headerlink" title="映射的基本操作"></a>映射的基本操作</h2><blockquote>
<p>在映射上的所有操作可被表示在下面的三种方法</p>
</blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>keys</td>
<td>这个方法返回一个包含映射中的每个键的迭代。</td>
</tr>
<tr>
<td>values</td>
<td>这个方法返回一个包含映射中的每个值的迭代。</td>
</tr>
<tr>
<td>isEmpty</td>
<td>如果映射为空此方法返回true，否则为false。</td>
</tr>
</tbody>
</table>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">object Test &#123;</div><div class="line">   def main(args: Array[String]) &#123;</div><div class="line">      val colors = Map(&quot;red&quot; -&gt; &quot;#FF0000&quot;,</div><div class="line">                       &quot;azure&quot; -&gt; &quot;#F0FFFF&quot;,</div><div class="line">                       &quot;peru&quot; -&gt; &quot;#CD853F&quot;)</div><div class="line"></div><div class="line">      val nums: Map[Int, Int] = Map()</div><div class="line"></div><div class="line">      println( &quot;Keys in colors : &quot; + colors.keys )</div><div class="line">      println( &quot;Values in colors : &quot; + colors.values )</div><div class="line">      println( &quot;Check if colors is empty : &quot; + colors.isEmpty )</div><div class="line">      println( &quot;Check if nums is empty : &quot; + nums.isEmpty )</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="给可变映射添加元素"><a href="#给可变映射添加元素" class="headerlink" title="给可变映射添加元素"></a>给可变映射添加元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">A += (&apos;I&apos; -&gt; 1)</div><div class="line">A += (&apos;J&apos; -&gt; 5)</div><div class="line">A += (&apos;K&apos; -&gt; 10)</div><div class="line">A += (&apos;L&apos; -&gt; 100)</div></pre></td></tr></table></figure>
<h2 id="串联映射"><a href="#串联映射" class="headerlink" title="串联映射"></a>串联映射</h2><blockquote>
<p>可以使用++运算符或映射。++()方法来连接两个或更多的映射，但同时增加了映射，将删除重复的键</p>
</blockquote>
<p>eg</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">object Test &#123;</div><div class="line">   def main(args: Array[String]) &#123;</div><div class="line">      val colors1 = Map(&quot;red&quot; -&gt; &quot;#FF0000&quot;,</div><div class="line">                        &quot;azure&quot; -&gt; &quot;#F0FFFF&quot;,</div><div class="line">                        &quot;peru&quot; -&gt; &quot;#CD853F&quot;)</div><div class="line">      val colors2 = Map(&quot;blue&quot; -&gt; &quot;#0033FF&quot;,</div><div class="line">                        &quot;yellow&quot; -&gt; &quot;#FFFF00&quot;,</div><div class="line">                        &quot;red&quot; -&gt; &quot;#FF0000&quot;)</div><div class="line"></div><div class="line">      // use two or more Maps with ++ as operator</div><div class="line">      var colors = colors1 ++ colors2</div><div class="line">      println( &quot;colors1 ++ colors2 : &quot; + colors )</div><div class="line"></div><div class="line">      // use two maps with ++ as method</div><div class="line">      colors = colors1.++(colors2)</div><div class="line">      println( &quot;colors1.++(colors2)) : &quot; + colors )</div><div class="line"></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="遍历Map"><a href="#遍历Map" class="headerlink" title="遍历Map"></a>遍历Map</h2><blockquote>
<p>方法很多,模式匹配最方便了</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">val colors = Map(&quot;red&quot; -&gt; &quot;#FF0000&quot;,</div><div class="line">  &quot;azure&quot; -&gt; &quot;#F0FFFF&quot;,</div><div class="line">  &quot;peru&quot; -&gt; &quot;#CD853F&quot;)</div><div class="line"></div><div class="line">println(&quot;第一种遍历&quot;)</div><div class="line">colors.keys.foreach&#123;key=&gt;</div><div class="line">print(&quot;key= &quot;+key)</div><div class="line">println(&quot; value= &quot;+colors(key))&#125;</div><div class="line"></div><div class="line">println(&quot;第二种遍历&quot;)</div><div class="line"></div><div class="line">for(key &lt;- colors.keySet.toArray) &#123;</div><div class="line">  println(key+&quot; :　&quot;+colors.get(key))</div><div class="line">&#125;</div><div class="line"></div><div class="line">println(&quot;第三种遍历&quot;)</div><div class="line"></div><div class="line">colors.map&#123;</div><div class="line">  case (k,v)=&gt;println(k+&quot; : &quot;+v)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="scala中Map的常用方法"><a href="#scala中Map的常用方法" class="headerlink" title="scala中Map的常用方法"></a>scala中Map的常用方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>def contains(key: A): Boolean</td>
<td>如果有一个绑定在该映射的键返回true，否则为false。</td>
</tr>
<tr>
<td>def clone(): Map[A, B]</td>
<td>创建接收器对象的副本</td>
</tr>
<tr>
<td>def clear(): Unit</td>
<td>从映射中删除所有绑定。在此之后操作已完成时，映射将是空的。</td>
</tr>
<tr>
<td>…..</td>
<td>…..</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h1><blockquote>
<p>Scala的元组结合多个固定数量在一起,使它们可以被传来传去作为一个整体.</p>
</blockquote>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>不像数组或列表,元组可以容纳不同类型的对象</li>
<li>同时记住,元组也是不可改变的</li>
<li>scala目前的元组上限在22个</li>
</ul>
<h2 id="声明Tuple元组"><a href="#声明Tuple元组" class="headerlink" title="声明Tuple元组"></a>声明Tuple元组</h2><p>一个元组的实际类型取决于它包含的元素和这些元素的类型的数目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">val t = (1, &quot;hello&quot;, Console)</div><div class="line"></div><div class="line">这是语法修饰(快捷方式)以下：</div><div class="line"></div><div class="line">val t = new Tuple3(1, &quot;hello&quot;, Console)</div><div class="line"></div><div class="line">//类型:</div><div class="line">// (99, &quot;Luftballons&quot;) 是 Tuple2[Int, String]</div><div class="line">// (&apos;u&apos;, &apos;r&apos;, &quot;the&quot;, 1, 4, &quot;me&quot;) 的类型是 Tuple6[Char, Char, String, Int, Int, String]</div></pre></td></tr></table></figure>
<h2 id="访问元组中的元素"><a href="#访问元组中的元素" class="headerlink" title="访问元组中的元素"></a>访问元组中的元素</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">object Test &#123;</div><div class="line">   def main(args: Array[String]) &#123;</div><div class="line">      val t = (4,3,2,1)</div><div class="line"></div><div class="line">      val sum = t._1 + t._2 + t._3 + t._4</div><div class="line"></div><div class="line">      println( &quot;Sum of elements: &quot;  + sum )</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="遍历元组"><a href="#遍历元组" class="headerlink" title="遍历元组"></a>遍历元组</h2><blockquote>
<p>可以使用Tuple.productIterator()方法来遍历一个元组的所有元素</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">object Test &#123;</div><div class="line">   def main(args: Array[String]) &#123;</div><div class="line">      val t = (4,3,2,1)</div><div class="line">      t.productIterator.foreach&#123; i =&gt;println(&quot;Value = &quot; + i )&#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="元组的简单方法"><a href="#元组的简单方法" class="headerlink" title="元组的简单方法"></a>元组的简单方法</h2><p>1.转换为字符串<br>2.交换元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">object Test &#123;</div><div class="line">   def main(args: Array[String]) &#123;</div><div class="line">      val t1 = new Tuple3(1, &quot;hello&quot;, Console)</div><div class="line">      println(&quot;Concatenated String: &quot; + t1.toString() )</div><div class="line"></div><div class="line">      val t2 = new Tuple2(&quot;Scala&quot;, &quot;hello&quot;)</div><div class="line"></div><div class="line">      println(&quot;Swapped Tuple: &quot; + t2.swap )</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/wei.png"
               alt="Hushiwei" />
          <p class="site-author-name" itemprop="name">Hushiwei</p>
           
              <p class="site-description motion-element" itemprop="description">时间渐行渐远</p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">26</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Timehsw" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/HswTime" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hushiwei</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"hushiwei"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  













  
  

  

  

  

  


  

</body>
</html>
